<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grootfish&#39;s blog</title>
  
  <subtitle>writing something</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://grootfish.github.io/"/>
  <updated>2020-12-29T03:10:57.228Z</updated>
  <id>https://grootfish.github.io/</id>
  
  <author>
    <name>grootfish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React &amp; Vue 对比</title>
    <link href="https://grootfish.github.io/2020/12/29/react-and-vue/"/>
    <id>https://grootfish.github.io/2020/12/29/react-and-vue/</id>
    <published>2020-12-29T03:10:57.228Z</published>
    <updated>2020-12-29T03:10:57.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写语法"><a href="#编写语法" class="headerlink" title="编写语法"></a>编写语法</h2><ul><li>vue推荐的做法是webpack+vue-loader的单文件组件格式</li><li>react 使用 JSX 的语法</li><li>vue 模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。JSX 使用 js 编写 DOM，代码可控性更强，更易调试</li></ul><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><ul><li>vue-cli &amp; create-react-app 前者提供多个可选模版，扩展性强。后者提供默认选项，复杂度低</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul><li>Vue采用数据劫持&amp;发布-订阅模式的方式，vue在创建vm的时候，会将数据配置在实例当中，然后通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，当获取数据的时候会触发对应的getter方法，当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后数据更改，vm则会进一步触发视图更新操作。</li><li>React是单向数据流，组件实例状态只能通过setState来进行更改。调用setState更新this.state，它不是马上就会生效的，它是异步的。所以不要认为调用完setState后可以立马获取到最新的值。多个顺序执行的setState不是同步的一个接着一个的执行，会加入一个异步队列，然后最后一起执行，即批处理</li></ul><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><ul><li>vue 中 diff 算法实现流程<ol><li>在内存中构建虚拟 DOM</li><li>将内存中虚拟 DOM 树渲染成真是 DOM 结构</li><li>数据改变的时候，将之前的虚拟 DOM 树结合新的数据生成新的虚拟 DOM</li><li>将新的虚拟DOM 和上一次虚拟DOM 树进行对比（diff 算法进行比对），来更新只需要被替换的 DOM,而不是全部重绘。在Diff 算法中，只平层比较前后两颗DOM 树的节点，没有进行深度遍历</li><li>将对比出来的差异进行重新渲染</li></ol></li><li>react 中 diff 算法实现流程<ol><li>在内存中构建虚拟 DOM 描述页面元素</li><li>state 变更的时候，将之前的虚拟 DOM 结合新的数据生成新的虚拟DOM</li><li>DOM 结构发生改变 → 直接卸载并重新 create</li><li>DOM 结构一样 → 不卸载 ，update 更新的属性</li><li>所有同一层级的子节点.他们都可以通过key来区分—–同时遵循1.2两点（key的存在与否只会影响diff算法的复杂度）</li><li>diff 总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。</li></ol></li><li>vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>vue组件内部自动实现判断组件是否需要重新渲染 （defineObjectProptype）</li><li>react 当props或state发生改变的时候会触发,shouldComponentUpdate生命周期函数，优化 render 逻辑</li><li>react 引入 immutable 库配合 shouldComponentUpdate 优化<br>原生支持</li><li>react native &amp; weex</li></ul><h2 id="ssr-服务端渲染"><a href="#ssr-服务端渲染" class="headerlink" title="ssr 服务端渲染"></a>ssr 服务端渲染</h2><ul><li>Next.js （React）&amp; Nuxt.js (Vue)</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>Vue<ul><li>初始化阶段 beforeCreate → created → beforeMount→mounted</li><li>更新阶段 beforeUpdated → updated</li><li>销毁阶段 beforeDestroy → destoryed</li><li>keep-alive 标签 active → deactive</li></ul></li><li>React<ul><li>初始化阶段 constructor → componentWillMount → shouldComponentUpdate → render → componentDidMount</li><li>更新阶段 getDerivedStateFromProps(componentWillReceiveProps) → shouldComponentUpdate → componentWillUpdate → render → componentDidUpdate</li><li>销毁阶段 componentWillUnmount</li></ul></li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul><li>vuex 的流程<ol><li>将需要共享的状态挂载到state上：this.$store.state来调用，vuex提供了mapState辅助函数，帮助我们在组件中获取并使用vuex的store中保存的状态。</li><li>我们通过getters来创建状态：通过this.$store.getters来调用</li><li>使用mutations来更改state：通过this.$store.commit来调用</li><li>使用actions来处理异步操作：this.$store.dispatch来调用</li></ol></li><li>redux 的流程<ol><li>创建store： 从redux工具中取出createStore去生成一个store。</li><li>创建一个reducer，然后将其传入到createStore中辅助store的创建。 reducer是一个纯函数，接收当前状态和action，返回一个状态，返回什么，store的状态就是什么，需要注意的是，不能直接操作当前状态，而是需要返回一个新的状态。 想要给store创建默认状态其实就是给reducer一个参数创建默认值。</li><li>组件通过调用store.getState方法来使用store中的state，挂载在了自己的状态上。</li><li>组件产生用户操作，调用actionCreator的方法创建一个action，利用store.dispatch方法传递给reducer</li><li>reducer对action上的标示性信息做出判断后对新状态进行处理，然后返回新状态</li><li>我们可以在组件中，利用store.subscribe方法去订阅数据的变化，也就是可以传入一个函数，当数据变化的时候，传入的函数会执行，在这个函数中让组件去获取最新的状态。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      框架
    
    </summary>
    
    
      <category term="React" scheme="https://grootfish.github.io/tags/React/"/>
    
      <category term="框架" scheme="https://grootfish.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="vue" scheme="https://grootfish.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="https://grootfish.github.io/2020/12/29/type-conversion/"/>
    <id>https://grootfish.github.io/2020/12/29/type-conversion/</id>
    <published>2020-12-29T03:10:57.228Z</published>
    <updated>2020-12-29T03:10:57.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><hr><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><blockquote><p>在<code>ECMAScript</code>中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p></blockquote><p>我们通常所说的对象，就是某个特定引用类型的实例。</p><p>在<code>ECMAScript</code>关于类型的定义中，只给出了<code>Object</code>类型，实际上，我们平时使用的很多引用类型的变量，并不是由<code>Object</code>构造的，但是它们原型链的终点都是<code>Object</code>，这些类型都属于引用类型。</p><ul><li><code>Array</code> 数组</li><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则</li><li><code>Function</code> 函数</li></ul><h3 id="6-1-包装类型"><a href="#6-1-包装类型" class="headerlink" title="6.1 包装类型"></a>6.1 包装类型</h3><p>为了便于操作基本类型值，<code>ECMAScript</code>还提供了几个特殊的引用类型，他们是基本类型的包装类型：</p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li></ul><p>注意包装类型和原始类型的区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> === <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="number">123</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">'ConardLi'</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'ConardLi'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'ConardLi'</span>)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'ConardLi'</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><blockquote><p>引用类型和包装类型的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span></span><br><span class="line">name.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="6-2-装箱和拆箱"><a href="#6-2-装箱和拆箱" class="headerlink" title="6.2 装箱和拆箱"></a>6.2 装箱和拆箱</h3><ul><li><p>装箱转换：把基本类型转换为对应的包装类型</p></li><li><p>拆箱操作：把引用类型转换为基本类型</p></li></ul><p>既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？</p><p>每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>实际上发生了以下几个过程：</p><ul><li>创建一个<code>String</code>的包装类型实例</li><li>在实例上调用<code>substring</code>方法</li><li>销毁实例</li></ul><p>也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用<code>Number</code>和<code>Boolean</code>类型时，也会发生这个过程。</p><p>从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循<code>ECMAScript规范</code>规定的<code>toPrimitive</code>原则，一般会调用引用类型的<code>valueOf</code>和<code>toString</code>方法，你也可以直接重写<code>toPeimitive</code>方法。一般转换成不同类型的值遵循的原则不同，例如：</p><ul><li>引用类型转换为<code>Number</code>类型，先调用<code>valueOf</code>，再调用<code>toString</code></li><li>引用类型转换为<code>String</code>类型，先调用<code>toString</code>，再调用<code>valueOf</code></li></ul><p>若<code>valueOf</code>和<code>toString</code>都不存在，或者没有返回基本类型，则抛出<code>TypeError</code>异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> <span class="number">123</span>; &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> <span class="string">'ConardLi'</span>; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj - <span class="number">1</span>);   <span class="comment">// valueOf   122</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>ConardLi`</span>); <span class="comment">// toString  ConardLiConardLi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'toPrimitive'</span>); <span class="keyword">return</span> <span class="number">123</span>; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2 - <span class="number">1</span>);   <span class="comment">// valueOf   122</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;; &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3 - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的<code>valueOf</code>或<code>toString</code>，实现拆箱操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> num.valueOf() ); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> num.toString() ); <span class="comment">//string</span></span><br></pre></td></tr></table></figure><h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2><p>因为<code>JavaScript</code>是弱类型的语言，所以类型转换发生非常频繁，上面我们说的装箱和拆箱其实就是一种类型转换。</p><p>类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。</p><p>强制转换这里就不再多提及了，下面我们来看看让人头疼的可能发生隐式类型转换的几个场景，以及如何转换：</p><h3 id="7-1-类型转换规则"><a href="#7-1-类型转换规则" class="headerlink" title="7.1 类型转换规则"></a>7.1 类型转换规则</h3><p>如果发生了隐式转换，那么各种类型互转符合下面的规则：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw0r9brsj30yr0u0q97.jpg" alt></p><h3 id="7-2-if语句和逻辑语句"><a href="#7-2-if语句和逻辑语句" class="headerlink" title="7.2 if语句和逻辑语句"></a>7.2 if语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="7-3-各种运数学算符"><a href="#7-3-各种运数学算符" class="headerlink" title="7.3 各种运数学算符"></a>7.3 各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span> <span class="comment">//  1</span></span><br><span class="line"><span class="number">1</span> * <span class="literal">undefined</span> <span class="comment">//  NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">'5'</span>] <span class="comment">//  10</span></span><br></pre></td></tr></table></figure><p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p><ul><li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">'123'</span> <span class="comment">// 123123   （规则1）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>  <span class="comment">// 123    （规则2）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span> <span class="comment">// 124    （规则2）</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;  <span class="comment">// 123[object Object]    （规则3）</span></span><br></pre></td></tr></table></figure><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4 =="></a>7.4 ==</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p><ul><li><strong>1.NaN</strong></li></ul><p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>2.Boolean</strong></li></ul><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'2'</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">'1'</span>]  <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">'2'</span>]  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>3.String和Number</strong></li></ul><p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">'123'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>4.null和undefined</strong></li></ul><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">''</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">''</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>5.原始类型和引用类型</strong></li></ul><p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'[object Object]'</span> == &#123;&#125; <span class="comment">// true</span></span><br><span class="line"><span class="string">'1,2,3'</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>来看看下面这个比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">null</span>] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">[<span class="literal">undefined</span>] == <span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p><p>所以，说了这么多，推荐使用<code>===</code>来判断两个值是否相等…</p><h3 id="7-5-一道有意思的面试题"><a href="#7-5-一道有意思的面试题" class="headerlink" title="7.5 一道有意思的面试题"></a>7.5 一道有意思的面试题</h3><p>一道经典的面试题，如何让：<code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code>。</p><p>根据上面的拆箱转换，以及<code>==</code>的隐式转换，我们可以轻松写出答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">   value:[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.value.pop(); &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、判断JavaScript数据类型的方式"><a href="#八、判断JavaScript数据类型的方式" class="headerlink" title="八、判断JavaScript数据类型的方式"></a>八、判断JavaScript数据类型的方式</h2><h3 id="8-1-typeof"><a href="#8-1-typeof" class="headerlink" title="8.1 typeof"></a>8.1 typeof</h3><p><strong>适用场景</strong></p><p><code>typeof</code>操作符可以准确判断一个变量是否为下面几个原始类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">'ConardLi'</span>  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>  <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()  <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>你还可以用它来判断函数类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p><strong>不适用场景</strong></p><p>当你用<code>typeof</code>来判断引用类型时似乎显得有些乏力了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> /^\d*$/; <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>除函数外所有的引用类型都会被判定为<code>object</code>。</p><p>另外<code>typeof null === &#39;object&#39;</code>也会让人感到头痛，这是在<code>JavaScript</code>初版就流传下来的<code>bug</code>，后面由于修改会造成大量的兼容问题就一直没有被修复…</p><h3 id="8-2-instanceof"><a href="#8-2-instanceof" class="headerlink" title="8.2 instanceof"></a>8.2 instanceof</h3><p><code>instanceof</code>操作符可以帮助我们判断引用类型具体是什么类型的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们先来回顾下原型链的几条规则：</p><ul><li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li><li>2.所有引用类型都具有一个<code>__proto__</code>（隐式原型）属性，是一个普通对象</li><li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li><li>4.所有引用类型<code>__proto__</code>值指向它构造函数的<code>prototype</code></li><li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>__proto__</code>中去找</li></ul><p><code>[] instanceof Array</code>实际上是判断<code>Array.prototype</code>是否在<code>[]</code>的原型链上。</p><p>所以，使用<code>instanceof</code>来检测数据类型，不会很准确，这不是它设计的初衷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>instanceof</code>也不能检测基本数据类型，所以<code>instanceof</code>并不是一个很好的选择。</p><h3 id="8-3-toString"><a href="#8-3-toString" class="headerlink" title="8.3 toString"></a>8.3 toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString() <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><p>注意，上面提到了<code>如果此方法在自定义对象中未被覆盖</code>，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p><p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw023janj30su0q0ah3.jpg" alt></p><h3 id="8-4-jquery"><a href="#8-4-jquery" class="headerlink" title="8.4 jquery"></a>8.4 jquery</h3><p>我们来看看<code>jquery</code>源码中如何进行类型判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line">jQuery.each( <span class="string">"Boolean Number String Function Array Date RegExp Object Error Symbol"</span>.split( <span class="string">" "</span> ),</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><br><span class="line">class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">type: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span> obj + <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</span><br><span class="line">class2type[<span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">"object"</span> :</span><br><span class="line"><span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFunction: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> jQuery.type(obj) === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始类型直接使用<code>typeof</code>，引用类型使用<code>Object.prototype.toString.call</code>取得类型，借助一个<code>class2type</code>对象将字符串多余的代码过滤掉，例如<code>[object function]</code>将得到<code>array</code>，然后在后面的类型判断，如<code>isFunction</code>直接可以使用<code>jQuery.type(obj) === &quot;function&quot;</code>这样的判断。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/9.0/index.html</a></li><li><a href="https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/" target="_blank" rel="noopener">https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/28</a></li><li><a href="https://juejin.im/post/5bc5c752f265da0a9a399a62" target="_blank" rel="noopener">https://juejin.im/post/5bc5c752f265da0a9a399a62</a></li><li><a href="https://juejin.im/post/5bbda2b36fb9a05cfd27f55e" target="_blank" rel="noopener">https://juejin.im/post/5bbda2b36fb9a05cfd27f55e</a></li><li>《JS高级程序设计》</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>了解<code>JavaScript</code>中的变量在内存中的具体存储形式，可对应实际场景</li><li>搞懂小数计算不精确的底层原因</li><li>了解可能发生隐式类型转换的场景以及转换原则</li><li>掌握判断<code>JavaScript</code>数据类型的方式和底层原理</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p><p>#学习/前端</p>]]></content>
    
    <summary type="html">
    
      前端基础
    
    </summary>
    
      <category term="javascript" scheme="https://grootfish.github.io/categories/javascript/"/>
    
      <category term="前端基础" scheme="https://grootfish.github.io/categories/javascript/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>hooks 已经到来</title>
    <link href="https://grootfish.github.io/2020/12/29/hooks/"/>
    <id>https://grootfish.github.io/2020/12/29/hooks/</id>
    <published>2020-12-29T03:10:57.226Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hooks-已经到来"><a href="#Hooks-已经到来" class="headerlink" title="Hooks 已经到来"></a>Hooks 已经到来</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>Redux 的作者 Dan Abramov 在 2018 年的 ReactConf 向大家首次介绍了 React Hooks。React Hooks 是为了解决 Class Component 的一些问题而引入的。</p><p>Vue 的作者尤雨溪在 VueConf China 2019 也给 Vue 3.0 引入了一个叫 Functional-based API 的概念，它是受 React Hooks 启发而增加的新 API。由于 Vue 2.0 组件组合的模式是对象字面量形式，所以 Functional-based API 可以作为 Mixins 的替代，配合新的响应式 API 作为新的组件组合模式。React 和 Vue 对于降低前端开发复杂度这一问题都不约而同地选择了 Hooks 这一方案，这到底是为什么呢？</p><h3 id="为什么要用-Hooks"><a href="#为什么要用-Hooks" class="headerlink" title="为什么要用 Hooks"></a>为什么要用 Hooks</h3><p>React Hooks 是为了解决 Class Component 的一些问题而引入的</p><ul><li>类组件间的逻辑难以复用。因为 JavaScript 不像 Go 或 C++ 一样，Class 可以多重继承，类的逻辑的复用就成了一个问题；</li><li>类组件经常会在生命周期做一些数据获取事件监听的副作用函数，这样的情况下我们就很难把组件拆分为更小的力度；</li><li>类组件 this 指向问题令人迷惑。很多新手应该会被 Class 组件绑定事件的 this 迷惑过，绑定事件可以用 bind，可以直接写箭头函数，也可以写类属性函数，但到底哪种方法才是最好的呢？</li></ul><p>Hooks 可以使我们模块化开发的粒度更细，更函数式。组件的功能变成了由 Hooks 一点点地装配起来。这样的特性，也解决了上面提到的痛点：代码复用、组件树过深、类组件问题。</p><p>对于代码逻辑复用，React 和 Vue 都提出过各自的解决方案，其中比较常用的逻辑复用方案是 <code>mixins</code>、<code>HOC</code>。这两种方案都可以实现逻辑上的复用，但是都有一些额外的问题:</p><ul><li>mixins 的问题：<ul><li>首先是命名空间耦合，如果多个对象同名参数，这些参数就会耦合在一起;</li><li>由于 mixins 必须是运行时才能知道具体有什么参数，所以是 TypeScript 是无法做静态检查的</li><li>组件参数不清晰，在 mixins 中组件的 props 和其他参数没什么两样，很容易被其它的 mixins 覆盖掉</li></ul></li><li>HOC 高阶组件的问题：<ul><li>需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，让调试变得困难；</li><li>每多用一次高阶组件，都会多出一个组件实例</li><li>在不遵守约定的情况下 props 还是有可能会在高阶组件中被更改</li></ul></li></ul><p>Hooks 的出现很好的解决了上面的问题。因为 Hooks 跑在一个普通函数式组件里，所以他没有命名空间的问题，同时 TypeScript 也能对普通函数做很好的静态检查，而且 Hooks 也不能更改组件的 Props，传入的是啥最后可用的就是啥；最后 Hooks 基于函数式编程，不会产生多个组件实例。</p><h3 id="Vue-Hooks-与-React-Hooks-的差异"><a href="#Vue-Hooks-与-React-Hooks-的差异" class="headerlink" title="Vue Hooks 与 React Hooks 的差异"></a>Vue Hooks 与 React Hooks 的差异</h3><h4 id="简单语法的差异"><a href="#简单语法的差异" class="headerlink" title="简单语法的差异"></a>简单语法的差异</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React hooks 的基本使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 firstName 状态变量</span></span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">'Billie'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持久化 name 数据的副作用</span></span><br><span class="line">  useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persist</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.value !== <span class="string">''</span>) &#123;</span><br><span class="line">      localStorage.setItem(<span class="string">'nameData'</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化 lastName 状态变量</span></span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">'Eilish'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新 title 的副作用</span></span><br><span class="line">  useEffect(<span class="function"><span class="keyword">function</span> <span class="title">updateTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue hooks 的基本使用</span></span><br><span class="line"><span class="keyword">import</span> &#123;ref, watch&#125; <span class="keyword">from</span> <span class="string">'Vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 使用 firstName 状态变量</span></span><br><span class="line">    <span class="keyword">const</span> firstName = ref(<span class="string">"Billie"</span>);</span><br><span class="line">    <span class="comment">// 使用一个 watcher 以持久化数据</span></span><br><span class="line">    <span class="keyword">if</span>(name.value !== <span class="string">''</span>) &#123;</span><br><span class="line">      watch(<span class="function"><span class="keyword">function</span> <span class="title">persist</span>(<span class="params"></span>) =&gt; </span>&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'nameData'</span>, name.value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 使用 lastName 状态变量</span></span><br><span class="line">   <span class="keyword">const</span> lastName = ref(<span class="string">"Eilish"</span>);</span><br><span class="line">   <span class="comment">// 使用一个 watcher 以更新 title</span></span><br><span class="line">   watch(<span class="function"><span class="keyword">function</span> <span class="title">updateTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.title = <span class="string">`<span class="subst">$&#123;firstName.value&#125;</span> <span class="subst">$&#123;lastName.value&#125;</span>`</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 中的 setup 仅执行一遍，而 React Function Component 每次渲染都会执行。</p><p>对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。</p><p>而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 setup 的更新，只在需要的时候更新自己的引用值即可，利用 Proxy 监听机制，可以做到 setup 函数不重新执行，但 Template 重新渲染的效果</p><h4 id="自定义-hooks-的差异"><a href="#自定义-hooks-的差异" class="headerlink" title="自定义 hooks 的差异"></a>自定义 hooks 的差异</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 中使用 hooks </span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义hook useMouse</span></span><br><span class="line"><span class="keyword">const</span> useMouse = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用hookuseState初始化一个state</span></span><br><span class="line">    <span class="keyword">const</span> [postion, setPostion] = useState(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        setPostion(&#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, handleMove);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, handleMove);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;, [postion]);</span><br><span class="line">    <span class="keyword">return</span> postion;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = useMouse(); <span class="comment">// 内部维护自己的postion相关的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            current position x: &#123;x&#125;, <span class="attr">y</span>: &#123;y&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 中使用 hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; value, computed, watch, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = value(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = value(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中使用该函数</span></span><br><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = useMouse()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到很多使用上的相同之处，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新。</p><p>不过在 React 中，useMouse 如果修改了 x 的值，那么使用 useMouse 的函数就会被重新执行，以此拿到最新的 x，而在 Vue 中利用 Proxy 监听机制，可以做到 setup 函数不重新执行，但 Template 重新渲染的效果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Hooks 的应用前景还是挺好的，解决了目前前端开发中的诸多痛点。不过 React Hooks 生态还不够完善，而 Vue 只有个 <a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener">Hooks POC</a>，Vue3.0 很可能会加上，但需要再等等。<br>本篇文章着重解释一下我对 Hooks 的理解，以及 Hooks API 在 Vue 和 React 框架中的不同。也说明一下 Hooks 是个中立的概念，可以在任何框架中使用。</p>]]></content>
    
    <summary type="html">
    
      react 知识整理
    
    </summary>
    
      <category term="React" scheme="https://grootfish.github.io/categories/React/"/>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
      <category term="react" scheme="https://grootfish.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>初始化 Mac 环境</title>
    <link href="https://grootfish.github.io/2020/12/29/init-mac/"/>
    <id>https://grootfish.github.io/2020/12/29/init-mac/</id>
    <published>2020-12-29T03:10:57.226Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<p>笔者使用的电脑是 Mac.拿到一台新 Mac 需要装各种环境 &amp; 软件。这篇文章主要做一个记录，减少初始化一台新 Mac 的时间，记录给自己用的，每个人的工作环境都不一样，没有参考性</p><h3 id="初始化终端"><a href="#初始化终端" class="headerlink" title="初始化终端"></a>初始化终端</h3><ul><li style="list-style: none"><input type="checkbox"> 先安装 macOS Command Line Tools <code>xcode-select --install</code></li><li style="list-style: none"><input type="checkbox"> 安装 homebrew (Mac 包管理工具)</li><li style="list-style: none"><input type="checkbox"> 使用 <a href="https://github.com/Homebrew/homebrew-bundle" target="_blank" rel="noopener">Homebrew Bundler</a> 初始化系统</li><li style="list-style: none"><input type="checkbox"> 安装 Iterm 2</li><li style="list-style: none"><input type="checkbox"> 安装 oh-my-zshell</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 把 zsh 设置成默认 shell</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把 zsh 加入 shell 列表</span></span><br><span class="line">sudo sh -c <span class="string">'echo /usr/local/bin/zsh &gt;&gt; /etc/shells'</span></span><br><span class="line"><span class="comment"># 设置 zsh 为默认 shell</span></span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 配置终端主题 &amp; 字体 (我使用 <a href="https://github.com/romkatv/powerlevel10k" target="_blank" rel="noopener">powerlevel10k</a>)</li><li style="list-style: none"><input type="checkbox"> 编辑器 VS code 增加终端快捷方式</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code ~/Applications/code</span><br></pre></td></tr></table></figure><h3 id="初始化编辑器"><a href="#初始化编辑器" class="headerlink" title="初始化编辑器"></a>初始化编辑器</h3><ul><li style="list-style: none"><input type="checkbox"> 编辑器配置都通过 <code>code-settings-sync</code> 保存在 gist,直接下载配置使用即可</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code --install-extension Shan.code-settings-sync</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li style="list-style: none"><input type="checkbox"> 配置 overWall 环境</li><li style="list-style: none"><input type="checkbox"> 按需安装应用</li></ul>]]></content>
    
    <summary type="html">
    
      初始化 Mac
    
    </summary>
    
      <category term="Mac" scheme="https://grootfish.github.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://grootfish.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>前端类型判断方法整理</title>
    <link href="https://grootfish.github.io/2020/12/29/javascript-type/"/>
    <id>https://grootfish.github.io/2020/12/29/javascript-type/</id>
    <published>2020-12-29T03:10:57.226Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-类型"><a href="#Javascript-类型" class="headerlink" title="Javascript 类型"></a>Javascript 类型</h1><ul><li>基本类型： String、Number、Boolean、Symbol、Undefined、Null</li><li>引用类型： Object</li></ul><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">""</span>; <span class="comment">//string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">//number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">//symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> undefinded; <span class="comment">//undefinded 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">//function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><ul><li>对于基本类型，除<code>null</code>以外，均可以返回正确的结果</li><li>对于引用类型，除了 <code>function</code> 以外，一律返回 object 类型</li><li>对于 null ，返回 object 类型</li><li>对于 function 返回 function 类型</li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p><em>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</em></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.constructor == <span class="built_in">String</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor == <span class="built_in">Number</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span>.constructor == <span class="built_in">Boolean</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor == <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>().constructor == <span class="built_in">Error</span>; <span class="comment">//true</span></span><br><span class="line">[].constructor == <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">document</span>.constructor == HTMLDocument; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">window</span>.constructor == Window; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>null 和 undefinde 是无效的对象，没有 constructor</li><li>函数的 constructor 是不稳定的，自定义对象，重写 prototype 后，原来的 constructor 引用丢失， constructor 会默认 Object</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funciotn F()&#123;&#125;</span><br><span class="line">F.prototype = &#123;<span class="attr">a</span>:<span class="string">'xxxx'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor == F; <span class="comment">//false</span></span><br><span class="line">f.constructor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><blockquote><p><em>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</em></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.toString(); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">""</span>); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(undefinded); <span class="comment">// [object Undefinde]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//[object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()); <span class="comment">//[object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">//[object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">//[object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>); <span class="comment">//[object Window]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      javascript 知识整理
    
    </summary>
    
      <category term="Javascript" scheme="https://grootfish.github.io/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS数组方法整理</title>
    <link href="https://grootfish.github.io/2020/12/29/javascript-array/"/>
    <id>https://grootfish.github.io/2020/12/29/javascript-array/</id>
    <published>2020-12-29T03:10:57.226Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量方式</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="string">"9"</span>]; <span class="comment">//[1,3,'9']</span></span><br><span class="line"><span class="comment">//构造器方法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(); <span class="comment">//[]</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//[,,]</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"9"</span>); <span class="comment">//[1,3,'9']</span></span><br><span class="line"><span class="comment">//ES6 Array.of()返回由所有参数值组成的数组</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"9"</span>); <span class="comment">//[1,3,'9']</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>.of(); <span class="comment">//[]</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">//[3]</span></span><br><span class="line"><span class="comment">//ES6 Array.from()将类数组对象转成真正的数组（不改变原对象，返回新数组）</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- 第一个（必需）：要转化为真正数组的对象</span></span><br><span class="line"><span class="comment">//- 第二个（可选）：类似数组的map方法，对每个元素进行处理，将处理结果放入返回的新数组中</span></span><br><span class="line"><span class="comment">//- 第三个（可选）：用来绑定this</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(obj); <span class="comment">//['a','b','c']</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="string">"hello"</span>); <span class="comment">//['h','e','l','l','o']</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"b"</span>]));</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="改变原数组的方法（9-个）"><a href="#改变原数组的方法（9-个）" class="headerlink" title="改变原数组的方法（9 个）"></a>改变原数组的方法（9 个）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line">a.splice();</span><br><span class="line">a.sort();</span><br><span class="line">a.pop();</span><br><span class="line">a.push();</span><br><span class="line">a.shift();</span><br><span class="line">a.unshift();</span><br><span class="line">a.revese();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">a.copyWithin();</span><br><span class="line">a.fill();</span><br></pre></td></tr></table></figure><h3 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.slice(begin, end); <span class="comment">//浅拷贝数组元素</span></span><br><span class="line">a.join(); <span class="comment">//数组转字符串</span></span><br><span class="line">a.toLocaleString();</span><br><span class="line">a.toString();</span><br><span class="line">a.concat();</span><br><span class="line">a.indexOf(); <span class="comment">//查找数组是否存在某个元素，返回下标</span></span><br><span class="line">a.lastIndexOf();</span><br><span class="line"><span class="comment">//定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 扩展运算符 ... 合并数组；</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, ...a, <span class="number">4</span>, <span class="number">4</span>]; <span class="comment">//[4,2,3,4,5,4,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES7 includes() 查找数组是否包含某个元素 返回布尔值</span></span><br><span class="line">a.includes(searchElement, (fromIndex = <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="遍历方法（12-个）"><a href="#遍历方法（12-个）" class="headerlink" title="遍历方法（12 个）"></a>遍历方法（12 个）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>);</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">every</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisValue</span>);</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">some</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisValue</span>);</span></span><br><span class="line"><span class="function"><span class="title">arr</span>.<span class="title">filter</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisArg</span>);</span></span><br><span class="line"><span class="function"><span class="title">arr</span>.<span class="title">map</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisArg</span>);</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">reduce</span>(<span class="params">function(total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>);</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">reduceRight</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">//<span class="title">ES6</span></span></span><br><span class="line"><span class="function"><span class="title">arr</span>.<span class="title">find</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"><span class="title">arr</span>.<span class="title">findIndex</span>(<span class="params">function(currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">keys</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">values</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">entries</span>(<span class="params"></span>);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      javascript 知识整理
    
    </summary>
    
      <category term="Javascript" scheme="https://grootfish.github.io/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="https://grootfish.github.io/2020/12/29/data-type-in-javascript/"/>
    <id>https://grootfish.github.io/2020/12/29/data-type-in-javascript/</id>
    <published>2020-12-29T03:10:57.225Z</published>
    <updated>2020-12-29T03:10:57.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">ECMAScript标准</a>规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p><p><strong>原始类型</strong></p><ul><li><code>Null</code>：只包含一个值：<code>null</code></li><li><code>Undefined</code>：只包含一个值：<code>undefined</code></li><li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li><li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li><li><code>String</code>：一串表示文本值的字符序列</li><li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul><p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p><p><strong>对象类型</strong></p><ul><li><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</li></ul><h2 id="二、为什么区分原始类型和对象类型"><a href="#二、为什么区分原始类型和对象类型" class="headerlink" title="二、为什么区分原始类型和对象类型"></a>二、为什么区分原始类型和对象类型</h2><h3 id="2-1-不可变性"><a href="#2-1-不可变性" class="headerlink" title="2.1 不可变性"></a>2.1 不可变性</h3><p>上面所提到的原始类型，在<code>ECMAScript</code>标准中，它们被定义为<code>primitive values</code>，即原始值，代表值本身是不可被改变的。</p><p>以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'ConardLi'</span>;</span><br><span class="line">str.slice(<span class="number">1</span>);</span><br><span class="line">str.substr(<span class="number">1</span>);</span><br><span class="line">str.trim(<span class="number">1</span>);</span><br><span class="line">str.toLowerCase(<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure><p>在上面的代码中我们对<code>str</code>调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code>，这就印证了字符串的不可变性。</p><p>那么，当我们继续调用下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">'6'</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi6</span></span><br></pre></td></tr></table></figure><p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p><p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p><p>内存空间又被分为两种，栈内存与堆内存。</p><p>栈内存：</p><ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul><p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw1g8rglj31560g8wfi.jpg" alt></p><p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p><p>在上面的代码中，我们执行了<code>str += &#39;6&#39;</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>&#39;ConardLi6&#39;</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrvxi919dj317o0hg40e.jpg" alt></p><h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p>堆内存：</p><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul><p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"ConardLi"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> obj4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw2393h2j31se0phn1z.jpg" alt></p><blockquote><p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<a href="https://juejin.im/post/5cb33660e51d456e811d2687" target="_blank" rel="noopener">JavaScript中的垃圾回收和内存泄漏</a>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p></blockquote><p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj1.name = <span class="string">"ConardLi6"</span>;</span><br><span class="line">obj2.age = <span class="number">19</span>;</span><br><span class="line">obj4.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:"ConardLi6"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age:19&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>以数组为例，它的很多方法都可以改变它自身。</p><ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li><li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li><li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li><li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li><li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul><p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name;</span><br><span class="line">name2 = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ConardLi;</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw2kaadsj31ii0me406.jpg" alt></p><p>内存中有一个变量<code>name</code>，值为<code>ConardLi</code>。我们从变量<code>name</code>复制出一个变量<code>name2</code>，此时在内存中创建了一个块新的空间用于存储<code>ConardLi</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p><p>复制一个引用类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br><span class="line">obj2.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw3oecc2j31oh0owq6n.jpg" alt></p><p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>obj2</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p><h3 id="2-4-比较"><a href="#2-4-比较" class="headerlink" title="2.4 比较"></a>2.4 比较</h3><p>当我们在对两个变量进行比较时，不同类型的变量的表现是不同的：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw422fe8j31om0qc0wn.jpg" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name === name2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj === obj2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>对于原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p><p>对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p><h3 id="2-5-值传递和引用传递"><a href="#2-5-值传递和引用传递" class="headerlink" title="2.5 值传递和引用传递"></a>2.5 值传递和引用传递</h3><p>借助下面的例子，我们先来看一看什么是值传递，什么是引用传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(name);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>执行上面的代码，如果最终打印出来的<code>name</code>是<code>&#39;ConardLi&#39;</code>，没有改变，说明函数参数传递的是变量的值，即值传递。如果最终打印的是<code>&#39;code秘密花园&#39;</code>，函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。</p><p>很明显，上面的执行结果是<code>&#39;ConardLi&#39;</code>，即函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure><p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p><p>首先明确一点，<code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p><p>同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'ConardLi'</span>;</span><br><span class="line">  obj = &#123;<span class="attr">name</span>:<span class="string">'code秘密花园'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure><p>可见，函数参数传递的并不是变量的<code>引用</code>，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住：</p><blockquote><p><code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p></blockquote><h2 id="三、分不清的null和undefined"><a href="#三、分不清的null和undefined" class="headerlink" title="三、分不清的null和undefined"></a>三、分不清的null和undefined</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfrw4hqvyxj30wu0dbq57.jpg" alt></p><p>在原始类型中，有两个类型<code>Null</code>和<code>Undefined</code>，他们都有且仅有一个值，<code>null</code>和<code>undefined</code>，并且他们都代表无和空，我一般这样区分它们：</p><p><strong>null</strong></p><p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p><p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p><p><strong>undefined</strong></p><p>表示“缺少值”，即此处应有一个值，但还没有定义，</p><p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p><p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)</p><p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p><h2 id="四、不太熟的Symbol类型"><a href="#四、不太熟的Symbol类型" class="headerlink" title="四、不太熟的Symbol类型"></a>四、不太熟的Symbol类型</h2><p><code>Symbol</code>类型是<code>ES6</code>中新加入的一种原始类型。</p><blockquote><p>每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p></blockquote><p>下面来看看<code>Symbol</code>类型具有哪些特性。</p><h3 id="4-1-Symbol的特性"><a href="#4-1-Symbol的特性" class="headerlink" title="4.1 Symbol的特性"></a>4.1 Symbol的特性</h3><p><strong>1.独一无二</strong></p><p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p><p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p><blockquote><p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>2.原始类型</strong></p><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>) === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure><p><strong>3.不可枚举</strong></p><p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p><blockquote><p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'ConardLi'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'name2'</span>)]:<span class="string">'code秘密花园'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Symbol的应用场景"><a href="#4-2-Symbol的应用场景" class="headerlink" title="4.2 Symbol的应用场景"></a>4.2 Symbol的应用场景</h3><p>下面是几个<code>Symbol</code>在程序中的应用场景。</p><p><strong>应用一：防止XSS</strong></p><p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>$$typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">'function'</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure><p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可见<code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉。</p><p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: <span class="string">'/* put your exploit here */'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;message.text&#125;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p><p><strong>应用二：私有属性</strong></p><p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = <span class="string">'ConardLi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getField()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  setField(val)&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用三：防止属性污染</strong></p><p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p><p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p><h2 id="五、不老实的Number类型"><a href="#五、不老实的Number类型" class="headerlink" title="五、不老实的Number类型"></a>五、不老实的Number类型</h2><p>为什么说<code>Number</code>类型不老实呢，相信大家都多多少少的在开发中遇到过小数计算不精确的问题，比如<code>0.1+0.2!==0.3</code>，下面我们来追本溯源，看看为什么会出现这种现象，以及该如何避免。</p><p>下面是我实现的一个简单的函数，用于判断两个小数进行加法运算是否精确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> MN = m + n;</span><br><span class="line">  <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">    result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制3.png" alt="image"></p><h3 id="5-1-精度丢失"><a href="#5-1-精度丢失" class="headerlink" title="5.1 精度丢失"></a>5.1 精度丢失</h3><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p><p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p><h3 id="5-2-对结果的分析—更多的问题"><a href="#5-2-对结果的分析—更多的问题" class="headerlink" title="5.2 对结果的分析—更多的问题"></a>5.2 对结果的分析—更多的问题</h3><p><code>0.1</code>和<code>0.2</code>的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果：</p><p><strong>0.1的二进制</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p><strong>0.2的二进制</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure></p><p><strong>理论上讲，由上面的结果相加应该：</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br></pre></td></tr></table></figure><p><strong>实际JS计算得到的0.1+0.2的二进制</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p>看到这里你可能会产生更多的问题：</p><blockquote><p>为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？</p></blockquote><blockquote><p>为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？</p></blockquote><blockquote><p>为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？</p></blockquote><h3 id="5-3-js对二进制小数的存储方式"><a href="#5-3-js对二进制小数的存储方式" class="headerlink" title="5.3 js对二进制小数的存储方式"></a>5.3 js对二进制小数的存储方式</h3><p>小数的<code>二进制</code>大多数都是无限循环的，<code>JavaScript</code>是怎么来存储他们的呢？</p><p>在<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.19" target="_blank" rel="noopener">ECMAScript®语言规范</a>中可以看到，<code>ECMAScript</code>中的<code>Number</code>类型遵循<code>IEEE 754</code>标准。使用64位固定长度来表示。</p><p>事实上有很多语言的数字类型都遵循这个标准，例如<code>JAVA</code>,所以很多语言同样有着上面同样的问题。</p><p>所以下次遇到这种问题不要上来就喷<code>JavaScript</code>…</p><p>有兴趣可以看看下这个网站<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>，是的，你没看错，就是<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>！！！</p><h3 id="5-4-IEEE-754"><a href="#5-4-IEEE-754" class="headerlink" title="5.4 IEEE 754"></a>5.4 IEEE 754</h3><p><code>IEEE754</code>标准包含一组实数的二进制表示法。它有三部分组成：</p><ul><li><p>符号位</p></li><li><p>指数位</p></li><li><p>尾数位</p></li></ul><p>三种精度的浮点数各个部分位数如下：</p><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制1.png" alt="image"></p><p><code>JavaScript</code>使用的是64位双精度浮点数编码，所以它的<code>符号位</code>占<code>1</code>位，指数位占<code>11</code>位，尾数位占<code>52</code>位。</p><p>下面我们在理解下什么是<code>符号位</code>、<code>指数位</code>、<code>尾数位</code>，以<code>0.1</code>为例：</p><p>它的二进制为：<code>0.0001100110011001100...</code></p><p>为了节省存储空间，在计算机中它是以科学计数法表示的，也就是</p><p><code>1.100110011001100...</code> X 2<sup>-4</sup></p><p>如果这里不好理解可以想一下十进制的数：</p><p><code>1100</code>的科学计数法为<code>11</code> X 10<sup>2</sup></p><p>所以：</p><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制2.png" alt="image"></p><p><code>符号位</code>就是标识正负的，<code>1</code>表示<code>负</code>，<code>0</code>表示<code>正</code>；</p><p><code>指数位</code>存储科学计数法的指数；</p><p><code>尾数位</code>存储科学计数法后的有效数字；</p><p>所以我们通常看到的二进制，其实是计算机实际存储的尾数位。</p><h3 id="5-5-js中的toString-2"><a href="#5-5-js中的toString-2" class="headerlink" title="5.5 js中的toString(2)"></a>5.5 js中的toString(2)</h3><p>由于尾数位只能存储<code>52</code>个数字，这就能解释<code>toString(2)</code>的执行结果了：</p><p>如果计算机没有存储空间的限制，那么<code>0.1</code>的<code>二进制</code>应该是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure></p><p>科学计数法尾数位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure><p>但是由于限制，有效数字第<code>53</code>位及以后的数字是不能存储的，它遵循，如果是<code>1</code>就向前一位进<code>1</code>，如果是<code>0</code>就舍弃的原则。</p><p>0.1的二进制科学计数法第53位是1，所以就有了下面的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p><code>0.2</code>有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了<code>0.1+0.2!=0.3</code>。</p><p>事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库：</p><ul><li><a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener">number-precision</a></li><li><a href="https://github.com/josdejong/mathjs/" target="_blank" rel="noopener">mathjs/</a></li></ul><h3 id="5-6-JavaScript能表示的最大数字"><a href="#5-6-JavaScript能表示的最大数字" class="headerlink" title="5.6 JavaScript能表示的最大数字"></a>5.6 JavaScript能表示的最大数字</h3><p>由与<code>IEEE 754</code>双精度64位规范的限制：</p><p><code>指数位</code>能表示的最大数字：<code>1023</code>(十进制)</p><p><code>尾数位</code>能表达的最大数字即尾数位都位<code>1</code>的情况</p><p>所以JavaScript能表示的最大数字即位</p><p><code>1.111...</code>X 2<sup>1023</sup> 这个结果转换成十进制是<code>1.7976931348623157e+308</code>,这个结果即为<code>Number.MAX_VALUE</code>。</p><h3 id="5-7-最大安全数字"><a href="#5-7-最大安全数字" class="headerlink" title="5.7 最大安全数字"></a>5.7 最大安全数字</h3><p>JavaScript中<code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字,计算结果是<code>9007199254740991</code>，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是<code>1.111...</code>X 2<sup>52</sup>。</p><p>我们同样可以用一些开源库来处理大整数：</p><ul><li><a href="https://github.com/justmoon/node-bignum" target="_blank" rel="noopener">node-bignum</a></li><li><a href="https://github.com/substack/node-bigint" target="_blank" rel="noopener">node-bigint</a></li></ul><p>其实官方也考虑到了这个问题，<code>bigInt</code>类型在<code>es10</code>中被提出，现在<code>Chrome</code>中已经可以使用，使用<code>bigInt</code>可以操作超过最大安全数字的数字。</p><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p><p>#学习/前端</p>]]></content>
    
    <summary type="html">
    
      Javascript 中的数据类型
    
    </summary>
    
      <category term="javascript" scheme="https://grootfish.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>使React hooks 重构你的应用</title>
    <link href="https://grootfish.github.io/2020/12/29/hooks-reconfiguration/"/>
    <id>https://grootfish.github.io/2020/12/29/hooks-reconfiguration/</id>
    <published>2020-12-29T03:10:57.225Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Hooks"><a href="#什么是-Hooks" class="headerlink" title="什么是 Hooks"></a>什么是 Hooks</h3><ul><li>React 一直都提倡使用函数组件，但是有时候需要使用 state 或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有</li><li>Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</li><li>如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks</li></ul><h3 id="为什么要使用-Hooks"><a href="#为什么要使用-Hooks" class="headerlink" title="为什么要使用 Hooks"></a>为什么要使用 Hooks</h3><p><strong>1. 类组件的不足</strong>    </p><ul><li>状态逻辑难复用： 在组件之间复用状态逻辑很难，可能要用到 render props （渲染属性）或者 HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），导致层级冗余</li><li>类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</li><li>this 指向问题：父组件给子组件传递函数时，必须绑定 this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">any</span>, <span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">    handleClick2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            num: <span class="number">1</span>,</span><br><span class="line">            title: <span class="string">' react study'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleClick2 = <span class="keyword">this</span>.handleClick1.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick1() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            num: <span class="keyword">this</span>.state.num + <span class="number">1</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            num: <span class="keyword">this</span>.state.num + <span class="number">1</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">            &lt;h2&gt;Ann, &#123;this.state.num&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick2&#125;&gt;btn1&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick1.bind(this)&#125;&gt;btn2&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; this.handleClick1()&#125;&gt;btn3&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick3&#125;&gt;btn4&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码是 react 中的组件四种绑定 this 方法的区别<ul><li>第一种是在构造函数中绑定 this：那么每次父组件刷新的时候，如果传递给子组件其他的 props 值不变，那么子组件就不会刷新；</li><li>第二种是在 render() 函数里面绑定 this：因为 bind 函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新；</li><li>第三种是使用箭头函数：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；</li><li>第四种是使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</li></ul></li></ul><p><em>2. Hooks 优势</em></p><ul><li>能优化类组件的三大问题</li><li>能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</li><li>能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li><li>副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如 ajax 请求、访问原生dom 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等。以往这些副作用都是写在类组件生命周期函数中的。</li></ul><h3 id="使用Hooks重构应用"><a href="#使用Hooks重构应用" class="headerlink" title="使用Hooks重构应用"></a>使用Hooks重构应用</h3><ol><li>使用 initialState 函数处理状态初始值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">token</span>: <span class="literal">null</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.token) &#123;</span><br><span class="line">      <span class="keyword">this</span>.state.token = <span class="keyword">this</span>.props.token</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      token = <span class="built_in">window</span>.localStorage.getItem(<span class="string">'app-token'</span>);</span><br><span class="line">      <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state.token = token</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> initState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(props.token) &#123;</span><br><span class="line">       <span class="keyword">return</span> props.token </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       tokenLocal = <span class="built_in">window</span>.localStorage.getItem(<span class="string">'app-token'</span>);</span><br><span class="line">       <span class="keyword">if</span> (tokenLocal) &#123;</span><br><span class="line">         <span class="keyword">return</span> tokenLocal</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> [token, setToken] = useState(initState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 useEffect 代替生命周期 return 值清除 effect 操作</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> [text,setText] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="comment">// 相当于componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">        <span class="keyword">let</span> $timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用</span></span><br><span class="line">        <span class="comment">// useEffect 在执行副作用函数之前，会先调用上一次返回的函数</span></span><br><span class="line">        <span class="comment">// 如果要清除副作用，要么返回一个清除副作用的函数</span></span><br><span class="line">       <span class="comment">/*  return ()=&gt;&#123;</span></span><br><span class="line"><span class="comment">            console.log('destroy effect');</span></span><br><span class="line"><span class="comment">            clearInterval($timer);</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// &#125;,[]);//要么在这里传入一个空的依赖项数组，这样就不会去重复执行</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;input value=&#123;text&#125; onChange=&#123;(event)=&gt;setText(event.target.value)&#125;/&gt;</span><br><span class="line">          &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button&gt;+&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 useReducer 简化代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer)</span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(<span class="function">(<span class="params">state, action</span>) =&gt;</span> newState)</span><br></pre></td></tr></table></figure><p>如果你之前使用过redux ，那你就知道action 必须接收一个带有type属性的对象。然而，在useReducer 中，reducer 函数可以接收一个 state 以及多个 action ,然后返回一个新的state对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppHooks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    data: <span class="literal">null</span>,</span><br><span class="line">    error: <span class="literal">null</span>,</span><br><span class="line">    loaded: <span class="literal">false</span>,</span><br><span class="line">    fetching: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [data,setData] = useState();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, newState</span>) =&gt;</span> (&#123; ...state, ...newState &#125;)</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(API_URL);</span><br><span class="line">    <span class="keyword">const</span> &#123; data, status &#125; = &#123;</span><br><span class="line">      data: <span class="keyword">await</span> response.json(),</span><br><span class="line">      status: response.status</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> setState(&#123;</span><br><span class="line">        data,</span><br><span class="line">        error: <span class="literal">true</span>,</span><br><span class="line">        loaded: <span class="literal">true</span>,</span><br><span class="line">        fetching: <span class="literal">false</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(&#123;</span><br><span class="line">      data,</span><br><span class="line">      error: <span class="literal">null</span>,</span><br><span class="line">      loaded: <span class="literal">true</span>,</span><br><span class="line">      fetching: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchData()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; error, data &#125; = state</span><br><span class="line">  <span class="keyword">return</span> error ? &lt;div&gt; Sorry, 网络异常 :( &lt;/div&gt; :</span><br><span class="line">    &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">' '</span>)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 useMemo 优化 useEffect中对象的比较</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNumberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// look here 👇</span></span><br><span class="line">  <span class="keyword">const</span> name = &#123;<span class="attr">firstName</span>: <span class="string">"name"</span>&#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Effect has been run!"</span>)</span><br><span class="line">  &#125;, [name])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [randomNumber, setRandomNumber] = useState(<span class="number">0</span>);    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &lt;h1&gt; &#123;randomNumber&#125; &lt;/h1&gt;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123; setRandomNumber(Math.random()) &#125;&#125;&gt;Generate random number!&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNumberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// look here 👇</span></span><br><span class="line">  <span class="keyword">const</span> name = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    firstName: <span class="string">"name"</span></span><br><span class="line">  &#125;), [])</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Effect has been run!"</span>)</span><br><span class="line">  &#125;, [name])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [randomNumber, setRandomNumber] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;randomNumber&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123; setRandomNumber(Math.random()) &#125;&#125;&gt;</span><br><span class="line">      Generate random number!&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使React hooks 重构你的应用
    
    </summary>
    
      <category term="React" scheme="https://grootfish.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://grootfish.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>在 React 中使用计算属性</title>
    <link href="https://grootfish.github.io/2020/12/29/computed-in-react/"/>
    <id>https://grootfish.github.io/2020/12/29/computed-in-react/</id>
    <published>2020-12-29T03:10:57.224Z</published>
    <updated>2020-12-29T03:10:57.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在-React-中使用计算属性"><a href="#在-React-中使用计算属性" class="headerlink" title="在 React 中使用计算属性"></a>在 React 中使用计算属性</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>初次见到计算属性一词是在 Vue 官方文档-<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">计算属性和侦听器</a>一节中。</p><blockquote><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。</p></blockquote><p>回想我们编写的 React 代码，是否也在 JSX（render 函数）中放入了太多的逻辑导致 <code>render</code> 函数过于庞大,难以维护？</p><h3 id="React-中的计算属性"><a href="#React-中的计算属性" class="headerlink" title="React 中的计算属性"></a>React 中的计算属性</h3><p>在 Vue 中计算属性有以下两点主要特性</p><ol><li><strong>计算属性以声明的方式创建依赖关系,依赖的 data 或 props 变更会触发重新计算并自动更新；</strong></li><li><strong>计算属性是基于它们的响应式依赖进行缓存的；</strong></li></ol><p>其实在 React 中计算属性随处可见，相信各位使用过 React 的读者都写过类似的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    firstName: <span class="string">''</span>,</span><br><span class="line">    lastName: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 在 render 函数中处理逻辑</span></span><br><span class="line">    <span class="keyword">const</span> &#123; firstName, lastName &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> fullName = <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> &lt;Fragment&gt;&#123;fullName&#125;&lt;/Fragment&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码里，render 函数里面的<code>fullName</code> 依赖了<code>props</code> 中的<code>firstName</code>和<code>lastName</code> 。<code>firstName</code> 或<code>lastName</code> 变更之后变量 <code>fullName</code> 都会自动更新。其实现原理是<strong>props 以及 state 的变化会导致 render 函数调用，进而重新计算衍生值。</strong></p><p>但是现在我们还是把计算逻辑放入了 render 函数中，更好的做法是把计算逻辑抽出来，简化 render 函数逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    firstName: <span class="string">''</span>,</span><br><span class="line">    lastName: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 render 中的逻辑抽成函数,减少render函数的臃肿</span></span><br><span class="line">  renderFullName() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; firstName, lastName &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> fullName = <span class="keyword">this</span>.renderFullName();</span><br><span class="line">    <span class="keyword">return</span> &lt;Fragment&gt;&#123;fullName&#125;&lt;/Fragment&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你了解 Vue 的话，那么你知道其中的 computed 计算属性，它的底层是使用了getter，只不过是对象的 getter，那么在 React 中我们也可以使用类的 getter 来实现计算属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    firstName: <span class="string">''</span>,</span><br><span class="line">    lastName: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过getter而不是函数形式，减少变量</span></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; firstName, lastName &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Fragment&gt;&#123;this.fullName&#125;&lt;/Fragment&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-memoization-优化计算属性"><a href="#使用-memoization-优化计算属性" class="headerlink" title="使用 memoization 优化计算属性"></a>使用 memoization 优化计算属性</h3><p>上文有提到在 Vue 中计算属性对比函数执行：会有缓存，减少计算，因为计算属性只有在它的相关依赖发生改变时才会重新求值。</p><p>这就意味着只要  firstName 和 lastName 还没有发生改变，多次访问 fullName 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p><p>那么是否 React 的 getter 也有缓存这个优势？？？  <strong>答案是：没有，react 中的 getter 并没有做缓存优化</strong>！</p><p>不过我们可以使用记忆化技术（memoization）来优化我们的计算属性，实现和 Vue 中计算属性一样的效果，我们需要在项目中引入 memoize-one 库，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">'memoize-one'</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Fragment, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    firstName: <span class="string">''</span>,</span><br><span class="line">    lastName: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果和上次参数一样，`memoize-one` 会重复使用上一次的值。</span></span><br><span class="line">  getFullName = memoize(<span class="function">(<span class="params">firstName, lastName</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFullName(<span class="keyword">this</span>.state.firstName, <span class="keyword">this</span>.state.lastName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Fragment&gt;&#123;this.fullName&#125;&lt;/Fragment&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-React-hooks-优化计算属性"><a href="#使用-React-hooks-优化计算属性" class="headerlink" title="使用 React hooks 优化计算属性"></a>使用 React hooks 优化计算属性</h3><p>上文在 React 中使用了 memoize-one 库实现了类似 Vue 计算属性（computed）的效果 —— 基于依赖缓存计算结果。得益于React 16.8 新推出的Hooks特性，我们可以对逻辑进行更优雅的封装。</p><p>首先，我们来介绍一下<code>useMemo</code>：</p><p>官方对<code>useMemo</code>的介绍在<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">这里</a>， 简而言之，就是我们传入一个<strong>回调函数</strong>和一个<strong>依赖列表</strong>，React会在依赖列表中的值变化时，调用这个回调函数，并将回调函数返回的结果进行缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="comment">// 使用 useMemo 函数缓存计算过程</span></span><br><span class="line">  <span class="keyword">const</span> renderFullName = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>, [</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;&#123;renderFullName&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了在 React 中如何实现计算属性，在 React 中实现了类似 Vue 计算属性（computed）的效果 —— 基于依赖缓存计算结果，实现逻辑计算与视图渲染的解耦，降低 render 函数的复杂度。</p><p>从业务开发角度来讲，Vue 提供的 API 极大地提高了开发效率。</p><p>React 官方虽然某些场景没有原生的 API 支持，但得益于活跃的社区，工作中遇到的问题总能找到解决方案，并且在摸索这些解决方案的同时，我们能够学习到诸多经典的编程思想，从而更加合理的运用框架、技术解决业务问题。</p>]]></content>
    
    <summary type="html">
    
      在 React 中使用计算属性
    
    </summary>
    
      <category term="React" scheme="https://grootfish.github.io/categories/React/"/>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
      <category term="React" scheme="https://grootfish.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 npm 管理包</title>
    <link href="https://grootfish.github.io/2019/03/30/npmpackages/"/>
    <id>https://grootfish.github.io/2019/03/30/npmpackages/</id>
    <published>2019-03-30T09:07:35.000Z</published>
    <updated>2020-12-29T03:10:57.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分布标签（dist-tags）补充语义版本控制（例如，v0.12）。使用它们来组织和标记不同版本的包。除了比 semver 编号更具人性可读性之外，标签还允许发布者更有效地分发他们的包。</p></blockquote><h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><p>要将标记添加到包的特定版本，请使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;]</span><br><span class="line">npm dist-tag rm &lt;pkg&gt; &lt;tag&gt;</span><br><span class="line">npm dist-tag ls [&lt;pkg&gt;]</span><br><span class="line"></span><br><span class="line">aliases: dist-tags</span><br></pre></td></tr></table></figure><h3 id="使用标签发布"><a href="#使用标签发布" class="headerlink" title="使用标签发布"></a>使用标签发布</h3><p>默认情况下，<code>npm publish</code>会使用标记标记您的包<code>latest</code>。如果使用该<code>--tag</code>标志，则可以指定要使用的另一个标记。例如，以下内容将使用<code>beta</code>标记发布您的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --tag beta</span><br></pre></td></tr></table></figure><h3 id="使用标签安装"><a href="#使用标签安装" class="headerlink" title="使用标签安装"></a>使用标签安装</h3><p>默认<code>npm install &lt;pkg&gt;</code>会使用<code>latest</code>标签。要覆盖此行为，请使用<code>npm install &lt;pkg&gt;@&lt;tag&gt;</code>。以下示例将安装<code>somepkg</code>已标记的版本<code>beta</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install somepkg@beta</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>因为<code>dist-tag</code>与<code>semver</code>共享相同的名称空间，所以请避免使用可能导致冲突的标记名称。最佳做法是避免使用以数字或字母<code>v</code>开头的标签。</p><h3 id="使用-npm-version"><a href="#使用-npm-version" class="headerlink" title="使用 npm version"></a>使用 <code>npm version</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid=&lt;prerelease-id&gt;] | from-git]</span><br><span class="line"></span><br><span class="line"><span class="string">'npm [-v | --version]'</span> to <span class="built_in">print</span> npm version</span><br><span class="line"><span class="string">'npm view &lt;pkg&gt; version'</span> to view a package<span class="string">'s published version</span></span><br><span class="line"><span class="string">'</span>npm ls<span class="string">' to inspect current package/dependency versions</span></span><br></pre></td></tr></table></figure><h3 id="npm-version-的hooks"><a href="#npm-version-的hooks" class="headerlink" title="npm version 的hooks"></a><code>npm version</code> 的<code>hooks</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"preversion"</span>: <span class="string">"npm test"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"npm run build &amp;&amp; git add -A dist"</span>,</span><br><span class="line">  <span class="string">"postversion"</span>: <span class="string">"git push &amp;&amp; git push --tags &amp;&amp; rm -rf build/temp"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如何使用dist-tags &amp; version标记包
    
    </summary>
    
    
      <category term="node" scheme="https://grootfish.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议栈及 OSI 参考模型</title>
    <link href="https://grootfish.github.io/2019/01/04/TCP-IP-and-OIS/"/>
    <id>https://grootfish.github.io/2019/01/04/TCP-IP-and-OIS/</id>
    <published>2019-01-04T07:35:42.000Z</published>
    <updated>2020-12-29T03:10:57.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h2><p>OSI 参考模型（Open System Interconnection Reference Model，开放式系统互联通信参考模型），是 ISO （国际标准化组织）组织在 1985 年研究的网络互联模型。该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。</p><h3 id="ISO-通信功能七个层次的划分原则是："><a href="#ISO-通信功能七个层次的划分原则是：" class="headerlink" title="ISO 通信功能七个层次的划分原则是："></a>ISO 通信功能七个层次的划分原则是：</h3><ul><li>网路中各节点都有相同的层次；</li><li>不同节点的同等层具有相同的功能；</li><li>同一节点内相邻层之间通过接口通信；</li><li>每一层使用下层提供的服务，并向其上层提供服务；</li><li>不同节点的同等层按照协议实现对等层之间的通信。</li></ul><h3 id="OSI-参考模型具有以下优点："><a href="#OSI-参考模型具有以下优点：" class="headerlink" title="OSI 参考模型具有以下优点："></a>OSI 参考模型具有以下优点：</h3><ul><li>简化了相关的网络操作；</li><li>提供设备间的兼容性和标准接口；</li><li>促进标准化工作；</li><li>结构上可以分隔，各层可以独立修改或者扩充；</li><li>易于实现和维护；</li><li>有利于大家学习、理解数据通讯网络。</li></ul><h3 id="各层功能详述如下"><a href="#各层功能详述如下" class="headerlink" title="各层功能详述如下"></a>各层功能详述如下</h3><ol><li>物理层 (Physical Layer)：物理层是 OSI 参考模型的最低层，它利用传输介质为数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送比特流，物理链路可能是铜线、卫星、微波或其他的通讯媒介。它关心的问题有：多少伏电压代表 1 ？多少伏电压代表 0 ？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。</li><li>数据链路层 (Data Link Layer)：数据链路层是为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧。数据帧中包含物理地址（又称 MAC 地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。</li><li>网络层 (Network Layer)：网络层是为传输层提供服务的，传送的协议数据单元称为数据包（分组）。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。</li><li>传输层 (Transport Layer)：传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题，传输层传送的协议数据单元称为数据段（报文）。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。</li><li>会话层 (Session Layer)：会话层主要功能是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。</li><li>表示层 (Presentation Layer)：表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</li><li>应用层 (Application Layer)：应用层是 OSI 参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。</li></ol><p><img src="https://i.loli.net/2019/01/04/5c2f100fc3cf7.png" alt="OSI模型.png"></p><h3 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h3><p>通常人们认为 OSI 模型的最上面三层（应用层、表示层和会话层）在 TCP/IP 组中是一个应用层。由于 TCP/IP 有一个相对较弱的会话层，由 TCP 和 RTP 下的打开和关闭连接组成，并且在 TCP 和 UDP 下的各种应用提供不同的端口号，这些功能能够被单个的应用程序（或者那些应用程序所使用的库）增加。与此相似的是，IP 是按照将它下面的网络当作一个黑盒子的思想设计的，这样在讨论 TCP/IP 的时候就可以把它当作一个独立的层。<br><img src="https://i.loli.net/2019/01/04/5c2f112fd8f70.png" alt="TCP:IP协议.png"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</p><p>一些特定的程序被认为运行在这个层上。它们提供服务直接支持用户应用。这些程序和它们对应的协议包括 HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（名称<-> IP 地址寻找）以及许多其他协议。 一旦从应用程序来的数据被编码成一个标准的应用层协议，它将被传送到 IP 栈的下一层。</-></p><p>在传输层，应用程序最常用的是 TCP 或者 UDP，并且服务器应用程序经常与一个公开的端口号相联系。服务器应用程序的端口由互联网号码分配局（IANA）正式地分配，但是现今一些新协议的开发者经常选择它们自己的端口号。由于在同一个系统上很少超过少数几个的服务器应用，端口冲突引起的问题很少。应用软件通常也允许用户强制性地指定端口号作为运行参数。</p><p>链接外部的客户端程序通常使用系统分配的一个随机端口号。监听一个端口并且通过服务器将那个端口发送到应用的另外一个副本以创建对等链接（如 IRC 上的 dcc 文件传输）的应用也可以使用一个随机端口，但是应用程序通常允许定义一个特定的端口范围的规范以允许端口能够通过实现网络地址转换（NAT）的路由器映射到内部。</p><p>每一个应用层（TCP/IP 参考模型的最高层）协议一般都会使用到两个传输层协议之一： 面向连接的 TCP 传输控制协议和无连接的包传输的 UDP 用户数据报文协议。 常用的应用层协议有：</p><ul><li>运行在 TCP 协议上的协议：<ul><li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li><li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP 协议的安全版本。</li><li>FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。</li><li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li><li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li><li>SSH（Secure Shell，用于替代安全性差的 TELNET），用于加密安全登陆用。</li></ul></li><li>运行在 UDP 协议上的协议：<ul><li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li><li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li><li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置 IP 地址。</li></ul></li><li>其他：<ul><li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在 TCP 和 UDP 协议上）。</li><li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在 TCP 和 UDP 协议上）。</li><li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。</li><li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li></ul></li></ul><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层（transport layer）的协议，能够解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在 TCP/IP 协议组中，传输协议也包括所给数据应该送给哪个应用程序。 在 TCP/IP 协议组中技术上位于这个层的动态路由协议通常被认为是网络层的一部分；一个例子就是 OSPF（IP 协议 89）。 TCP（IP 协议 6）是一个“可靠的”、面向链接的传输机制，它提供一种可靠的字节流保证数据完整、无损并且按顺序到达。TCP 尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP 试图将数据按照规定的顺序发送。这是它与 UDP 不同之处，这在实时数据流或者路由高网络层丢失率应用的时候可能成为一个缺陷。 较新的 SCTP 也是一个“可靠的”、面向链接的传输机制。它是面向纪录而不是面向字节的，它在一个单独的链接上提供通过多路复用提供的多个子流。它也提供多路自寻址支持，其中链接终端能够被多个 IP 地址表示（代表多个实体接口），这样的话即使其中一个连接失败了也不中断。它最初是为电话应用开发的（在 IP 上传输 SS7），但是也可以用于其他的应用。 UDP（IP 协议号 17）是一个无链接的数据报协议。它是一个“尽力传递”（best effort）或者说“不可靠”协议——不是因为它特别不可靠，而是因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。如果一个应用程序需要这些特性，那它必须自行检测和判断，或者使用 TCP 协议。 UDP 的典型性应用是如流媒体（音频和视频等）这样按时到达比可靠性更重要的应用，或者如 DNS 查找这样的简单查询／响应应用，如果创建可靠的链接所作的额外工作将是不成比例地大。 DCCP 当前正由 IEFT 开发。它提供 TCP 流动控制语义，但对于用户来说保留 UDP 的数据报服务模型。 TCP 和 UDP 都用来支持一些高层的应用。任何给定网络地址的应用通过它们的 TCP 或者 UDP 端口号区分。根据惯例使一些大众所知的端口与特定的应用相联系。 RTP 是为如音频和视频流这样的实时数据设计的数据报协议。RTP 是使用 UDP 包格式作为基础的会话层，然而据说它位于因特网协议栈的传输层。</p><h4 id="网络互连层"><a href="#网络互连层" class="headerlink" title="网络互连层"></a>网络互连层</h4><p>TCP/IP 协议族中的网络互连层（internet layer）在 OSI 模型中叫做网络层（network layer）。</p><p>正如最初所定义的，网络层解决在一个单一网络上传输数据包的问题。类似的协议有 X.25 和 ARPANET 的 Host/IMP Protocol。 随着因特网思想的出现，在这个层上添加附加的功能，也就是将数据从源网络传输到目的网络。这就牵涉到在网络组成的网上选择路径将数据包传输，也就是因特网。 在因特网协议组中，IP 完成数据从源发送到目的的基本任务。IP 能够承载多种不同的高层协议的数据；这些协议使用一个唯一的 IP 协议号进行标识。ICMP 和 IGMP 分别是 1 和 2。 一些 IP 承载的协议，如 ICMP（用来发送关于 IP 发送的诊断信息）和 IGMP（用来管理多播数据），它们位于 IP 层之上但是完成网络层的功能，这表明因特网和 OSI 模型之间的不兼容性。所有的路由协议，如 BGP、OSPF、和 RIP 实际上也是网络层的一部分，尽管它们似乎应该属于更高的协议栈。</p><h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>网络接口层实际上并不是因特网协议组中的一部分，但是它是数据包从一个设备的网络层传输到另外一个设备的网络层的方法。这个过程能够在网卡的软件驱动程序中控制，也可以在韧体或者专用芯片中控制。这将完成如添加报头准备发送、通过实体介质实际发送这样一些数据链路功能。另一端，链路层将完成数据帧接收、去除报头并且将接收到的包传到网络层。 然而，链路层并不经常这样简单。它也可能是一个虚拟专有网络（VPN）或者隧道，在这里从网络层来的包使用隧道协议和其他（或者同样的）协议组发送而不是发送到实体的接口上。VPN 和信道通常预先建好，并且它们有一些直接发送到实体接口所没有的特殊特点（例如，它可以加密经过它的数据）。由于现在链路“层”是一个完整的网络，这种协议组的递归使用可能引起混淆。但是它是一个实现常见复杂功能的一个优秀方法。（尽管需要注意预防一个已经封装并且经隧道发送下去的数据包进行再次地封装和发送）。</p>]]></content>
    
    <summary type="html">
    
      TCP/IP 协议栈及 OSI 参考模型详解
    
    </summary>
    
    
      <category term="http" scheme="https://grootfish.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>使用 dva 开发 React 应用</title>
    <link href="https://grootfish.github.io/2018/12/20/develop-with-dva/"/>
    <id>https://grootfish.github.io/2018/12/20/develop-with-dva/</id>
    <published>2018-12-20T06:13:56.000Z</published>
    <updated>2020-12-29T03:10:57.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="约定先行"><a href="#约定先行" class="headerlink" title="约定先行"></a>约定先行</h2><ul><li>公共组件统一放到 <code>components</code> 目录下，公共组件建议添加 <code>propTypes</code> 和 <code>defaultProps</code></li><li>页面组件统一放到 <code>routes</code> 目录下<ul><li><code>services</code>目录定义接口调用</li><li><code>models</code>目录定义 Dva 的 models</li><li><code>views</code>目录处理页面渲染逻辑</li><li><code>constants.js</code> 定义组件常量（可选）</li><li><code>config.js</code> 定义组件配置（可选）</li></ul></li><li>所有事件监听的方法都用 <code>handle</code> 开头。</li><li>把事件监听方法传给组件的时候，属性名用 <code>on</code> 开头</li><li>有时候 <code>render()</code> 方法里面的内容会分开到不同函数里面进行，这些函数都以 <code>render*</code> 开头</li><li>组件的内容编写顺序<ol><li><code>static</code> 开头的类属性，如 <code>defaultProps</code>、<code>propTypes</code>。</li><li>构造函数，<code>constructor</code>。</li><li><code>getter/setter</code>方法。</li><li>组件生命周期。</li><li>组件私有方法。</li><li>事件监听方法，<code>handle*</code>。</li><li><code>render*</code>开头的方法。</li><li><code>render()</code> 方法。</li></ol></li></ul><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="Step-1-安装-dva-cli-并创建应用"><a href="#Step-1-安装-dva-cli-并创建应用" class="headerlink" title="Step 1. 安装 dva-cli 并创建应用"></a>Step 1. 安装 dva-cli 并创建应用</h3><p>先安装 dva-cli，并确保版本是 1.0.0-beta.2 或以上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm i dva-cli@next -g</span><br><span class="line">$ dva -v</span><br><span class="line">1.0.0-beta.4</span><br></pre></td></tr></table></figure><p>然后创建应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dva new dashboard</span><br><span class="line">$ <span class="built_in">cd</span> dashboard</span><br></pre></td></tr></table></figure><h3 id="Step-2-定义路由"><a href="#Step-2-定义路由" class="headerlink" title="Step 2. 定义路由"></a>Step 2. 定义路由</h3><p>修改页面组件<code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">"/demands/list"</span>,</span><br><span class="line">    view: <span class="string">"list"</span>,</span><br><span class="line">    models: [<span class="string">"list"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">"/demands/detail"</span>,</span><br><span class="line">    view: <span class="string">"detail"</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="Step-3-构造-service-文件"><a href="#Step-3-构造-service-文件" class="headerlink" title="Step 3. 构造 service 文件"></a>Step 3. 构造 service 文件</h3><p>新增<code>src/routes/Demand/services/list.js</code>，内容如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">"/api/demand/list"</span>, &#123;</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      ...params</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-4-构造-models-文件"><a href="#Step-4-构造-models-文件" class="headerlink" title="Step 4. 构造 models 文件"></a>Step 4. 构造 models 文件</h3><p>新增 <code>src/routes/Demand/models/list.js</code>，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> demandService <span class="keyword">from</span> <span class="string">"../services/list"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PAGE_SIZE &#125; <span class="keyword">from</span> <span class="string">"../constants"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">"demands"</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    pageNo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    save(state,&#123;<span class="attr">payload</span>: &#123; <span class="attr">data</span>: list, pageNo &#125;&#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, list, pageNo &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; result &#125; = <span class="keyword">yield</span> call(demandService.fetch, payload);</span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = result;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">"save"</span>,</span><br><span class="line">        payload: &#123; data, <span class="attr">pageNo</span>: payload.pageNo &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pathname === <span class="string">"/demands/list"</span>) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: <span class="string">"fetch"</span>,</span><br><span class="line">            payload: &#123; <span class="attr">pageSize</span>: PAGE_SIZE, <span class="attr">pageNo</span>: <span class="number">1</span> &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Step-5-添加界面，让列表展现出来"><a href="#Step-5-添加界面，让列表展现出来" class="headerlink" title="Step 5. 添加界面，让列表展现出来"></a>Step 5. 添加界面，让列表展现出来</h3><p>我们把组件存在 <code>src/routes/Demand/views/list.js</code> 里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"../index.less"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demands</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div className="demands"&gt;需求列表&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Demands;</span><br></pre></td></tr></table></figure><h3 id="Step-7-处理-loading-状态"><a href="#Step-7-处理-loading-状态" class="headerlink" title="Step 7. 处理 loading 状态"></a>Step 7. 处理 loading 状态</h3><p>dva 有一个管理 effects 执行的 hook，并基于此封装了 dva-loading 插件。通过这个插件，我们可以不必一遍遍地写 showLoading 和 hideLoading，当发起请求时，插件会自动设置数据里的 loading 状态为 true 或 false 。然后我们在渲染 components 时绑定并根据这个数据进行渲染。</p><p>然后在 <code>src/routes/Demand/views/list.js</code> 里绑定 loading 数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ loading: state.loading.models.users,</span><br></pre></td></tr></table></figure><h3 id="Step-8-处理数据-CURD"><a href="#Step-8-处理数据-CURD" class="headerlink" title="Step 8. 处理数据 CURD"></a>Step 8. 处理数据 CURD</h3><ul><li><p>CURD 的功能调整基本都可以按照以下三步进行：</p><ol><li>services</li><li>models</li><li>views</li></ol></li><li><p>我们以删除功能为例</p><p>1 . services, 修改 <code>src/routes/Demand/services/list.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">`/api/demand/delete/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 . models, 修改 <code>src/routes/Demand/models/list.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*remove(&#123; payload &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> call(demandService.remove, payload);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: &#123; <span class="attr">pageSize</span>: PAGE_SIZE, <span class="attr">pageNo</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3 . views,修改 src/routes/Demand/views/list.js，替换 handleDelete 内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123; <span class="attr">type</span>: <span class="string">"demands/remove"</span>, <span class="attr">payload</span>: id &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="技术栈一览"><a href="#技术栈一览" class="headerlink" title="技术栈一览"></a>技术栈一览</h2><p><img src="https://www.dropbox.com/s/f2h92qac5cw11z1/Dva.png?dl=0" alt="dva技术栈"></p>]]></content>
    
    <summary type="html">
    
      使用dva开发用户管理的 CURD 应用
    
    </summary>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
      <category term="React" scheme="https://grootfish.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>终端命令和快捷键</title>
    <link href="https://grootfish.github.io/2018/12/10/command-in-terminal/"/>
    <id>https://grootfish.github.io/2018/12/10/command-in-terminal/</id>
    <published>2018-12-10T07:28:14.000Z</published>
    <updated>2020-12-29T03:10:57.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者使用的是 Mac 电脑，终端使用的是 Iterm + zsh，本文只是对常用命令的整理，方便自己记忆，没有参考意义</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul><li><p><code>ls</code>显示在存放在相应文件系统下的所有主要目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /applications</span><br><span class="line">ls -a #显示所有隐藏的文件</span><br></pre></td></tr></table></figure></li><li><p><code>cat</code> 查看文件内容</p></li><li><p><code>ps</code> 命令用于查看系统的进程状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -a</span><br><span class="line">ps -x</span><br><span class="line"># USER 所属用户</span><br><span class="line"># PID 进程ID</span><br><span class="line"># TTY 所属终端</span><br><span class="line"># VSZ 虚拟内存使用量(KB)</span><br><span class="line"># RSS 物理内存使用量(KB)</span><br><span class="line"># STAT 进程状态 R:运行  S:中断  D:不可中断 Z:僵死 T:停止</span><br></pre></td></tr></table></figure></li><li><p><code>who</code> 命令用于查看当前用户信息</p></li><li><code>history</code> 用于显示运行过的命令，默认是记录最近的 1000 条命令</li><li><code>ifconfig</code> 命令用于查看网卡配置和网络状态信息</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><p><code>cd</code> 用来跳转（或“更改”）到一个目录的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Gym\ Playlist # 空格需要转译</span><br></pre></td></tr></table></figure></li><li><p><code>mv</code>将文件从一个文件夹转移到另一个文件夹</p></li><li><code>mkdir</code> 创建目录或文件夹</li><li><code>rmdir</code> 删除目录或文件夹</li><li><code>rm</code> 删除文件</li><li><code>touch</code> 创建新的、空的文件</li><li><code>vi/vim</code> 编辑文件</li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul><li><p>sudo 命令用于以 root 管理员权限运行某命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo poweroff # 使用 root 权限执行 poweroff 命令</span><br><span class="line">su - # 切换到 root 账户</span><br><span class="line">sudo !! #以 root 权限运行上一条命令</span><br></pre></td></tr></table></figure></li><li><p>poweroff 用于关闭系统,reboot 用于重启系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poweroff #关闭系统</span><br><span class="line"></span><br><span class="line">reboot #重启系统·</span><br></pre></td></tr></table></figure></li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li><p>echo 命令用于将字符串和变量输出到屏幕上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hi # 输出字符串</span><br><span class="line">echo $SHELL # 输出变量</span><br></pre></td></tr></table></figure></li><li><p>cal 命令用于输出一个日历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal # 输出这个月日历</span><br><span class="line">cal 2018 # 输出 2018 年日历</span><br><span class="line">cal 6 2018 # 输出 2018 年 6 月日历</span><br></pre></td></tr></table></figure></li><li><p>date 命令用于显示或设置系统的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date # 显示当前日期</span><br><span class="line">date -s &quot;20180428 7:15:00&quot; # 设置指定日期</span><br><span class="line">date &quot;+%j&quot; # 显示当天是当年的第几天</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot; # 以另一种格式显示当前日期</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="iterm-快捷键"><a href="#iterm-快捷键" class="headerlink" title="iterm 快捷键"></a>iterm 快捷键</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 1/2 command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 command + [ 或 command + ]</li><li>查看历史命令：command + ;</li><li>查看剪贴板历史：command + shift + h</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>清除当前行：ctrl + u</li><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>前进后退：ctrl + f/b (相当于左右方向键)</li><li>上一条命令：ctrl + p</li><li>搜索命令历史：ctrl + r</li><li>删除当前光标的字符：ctrl + d</li><li>删除光标之前的字符：ctrl + h</li><li>删除光标之前的单词：ctrl + w</li><li>删除到文本末尾：ctrl + k</li><li>交换光标处文本：ctrl + t</li><li>清屏 1：command + r</li><li>清屏 2：ctrl + l</li></ul>]]></content>
    
    <summary type="html">
    
      terminal
    
    </summary>
    
    
      <category term="工具" scheme="https://grootfish.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>React 中的代码复用</title>
    <link href="https://grootfish.github.io/2018/12/02/reuse-in-react/"/>
    <id>https://grootfish.github.io/2018/12/02/reuse-in-react/</id>
    <published>2018-12-02T06:51:27.000Z</published>
    <updated>2020-12-29T03:10:57.228Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司老项目打算使用React进行代码重构，交易模块有很多重复的逻辑，代码复用性非常重要，直接关系之后扩展业务的代码量。所以整理下在 React 中代码复用的方法。</p><h2 id="纯函数（Pure-Function）"><a href="#纯函数（Pure-Function）" class="headerlink" title="纯函数（Pure Function）"></a>纯函数（Pure Function）</h2><p>在讲复用性之前，我不得不介绍一下一个函数式编程里面非常重要的概念 —— 纯函数（Pure Function）。<br><em>一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数</em> 我们把纯函数的定义拆开来看：</p><ol><li>函数的返回结果只依赖于它的参数。</li><li>函数执行过程里面没有副作用。</li></ol><p>具体代码我不展开了，有兴趣可以自行Google</p><h2 id="为什么要提纯函数（Pure-Function）"><a href="#为什么要提纯函数（Pure-Function）" class="headerlink" title="为什么要提纯函数（Pure Function）"></a>为什么要提纯函数（Pure Function）</h2><ul><li>因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。</li><li>纯函数的特性正视我们在构建可复用代码的时候所需要的</li></ul><h2 id="代码复用方法"><a href="#代码复用方法" class="headerlink" title="代码复用方法"></a>代码复用方法</h2><h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h3><blockquote><p>The term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function.</p></blockquote><p>使用 Render Props 来处理代码复用问题的类库包括 <a href="https://reacttraining.com/react-router/web/api/Route" target="_blank" rel="noopener">React Router</a> 和 <a href="https://github.com/paypal/downshift" target="_blank" rel="noopener">Downshift</a>.</p><p>借用官网的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleMouseMove = <span class="keyword">this</span>.handleMouseMove.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">height</span>: <span class="string">'100%'</span> &#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* ...but how do we render something other than a &lt;p&gt;?</span></span><br><span class="line"><span class="comment">        &lt;p&gt;The current mouse position is (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt; */</span>&#125;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">          Instead of providing a static representation of what &lt;Mouse&gt; renders,</span></span><br><span class="line"><span class="comment">          use the `render` prop to dynamically determine what to render.</span></span><br><span class="line"><span class="comment">        */</span>&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="keyword">this</span>.props.mouse;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;img src=<span class="string">"/cat.jpg"</span> style=&#123;&#123; <span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouseTracker</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Move the mouse around!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Mouse render=&#123;mouse =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;Cat mouse=&#123;mouse&#125; /</span>&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><blockquote><p>a higher-order component is a function that takes a component and returns a new component.</p></blockquote><h4 id="最简单的高阶组件"><a href="#最简单的高阶组件" class="headerlink" title="最简单的高阶组件"></a>最简单的高阶组件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (WrappedComponent) =&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NewComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以做很多自定义逻辑</span></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NewComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在看来好像什么用都没有，它就是简单的构建了一个新的组件类 NewComponent，然后把传进入去的 WrappedComponent 渲染出来。但是我们可以给 NewCompoent 做一些数据启动工作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (WrappedComponent, name) =&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NewComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      <span class="keyword">let</span> data = localStorage.getItem(name)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent data=&#123;this.state.data&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NewComponent</span><br></pre></td></tr></table></figure></p><h4 id="我们可以这样使用它"><a href="#我们可以这样使用它" class="headerlink" title="我们可以这样使用它"></a>我们可以这样使用它</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wrapWithLoadData <span class="keyword">from</span> <span class="string">'./wrapWithLoadData'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputWithUserName</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input value=&#123;this.props.data&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputWithUserName = wrapWithLoadData(InputWithUserName, <span class="string">'username'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> InputWithUserName</span><br></pre></td></tr></table></figure><h3 id="React-hooks"><a href="#React-hooks" class="headerlink" title="React hooks"></a>React hooks</h3><ul><li><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">reat hooks</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本来想整理以下 React 中代码复用的知识的，但写到最后发现这是一个很大的题目。光靠一篇文章根本讲不好，权当我把自己的想法写出来吧，后续得再深入研究再来分享吧。逃ing….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司老项目打算使用React进行代码重构，交易模块有很多重复的逻辑，代码复用性非常重要，直接关系之后扩展业务的代码量。所以整理下在 React 中代码复用的方法。&lt;/p&gt;
&lt;h2 id=&quot;纯函数（Pure-Function）&quot;&gt;&lt;a href=&quot;#纯函数（Pure-Fu
      
    
    </summary>
    
    
      <category term="React" scheme="https://grootfish.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>工欲善其事，必先利其器</title>
    <link href="https://grootfish.github.io/2018/11/15/edge-tool/"/>
    <id>https://grootfish.github.io/2018/11/15/edge-tool/</id>
    <published>2018-11-15T08:39:25.000Z</published>
    <updated>2020-12-29T03:10:57.225Z</updated>
    
    <content type="html"><![CDATA[<p>我算是半个工具控，有段时间会追求效率工具，希望工具能提高生产力。现在意识到工具可以给你提供帮助，但真正想提高效率还是要靠自己，提高自己才是最大的收益。当然也没必要排斥工具，善假于物而不为物所迷即可</p><blockquote><p>君子生非异也，善假于物也 –荀子《劝学》</p></blockquote><h2 id="效率类"><a href="#效率类" class="headerlink" title="效率类"></a>效率类</h2><ul><li>XMind 思维导图工具</li><li>原生邮箱 勉强够用</li><li>原生备忘录 同步速度快，适配性好</li><li>原生提醒事项 简单够用</li><li>1Password 我的密码管家</li><li>Dropbox 保护隐私，同步速度快</li><li>Paste 剪贴板工具</li><li>极光词典 移动端字典</li><li>Office Lens 微软家的 OCR 工具 够用</li><li>白描 中文 OCR</li><li><del>印象笔记</del> 启动速度慢已弃用</li></ul><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><ul><li>Apple Music 国区便宜</li><li>Spotify 版权全</li><li>网易云音乐 国内歌曲</li></ul><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>Instapper 稍后读工具</li><li>Fiery Feeds Rss 阅读器</li><li>Price Tag 了解一些软件降价信息</li><li>Kindle 阅读书籍</li><li>微信读书</li><li>PPHub 刷 GitHub 用</li></ul><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><ul><li>微信 天朝必装吧</li><li>iMessage 家人交流</li><li>钉钉 办公交流用</li><li>Telegram 了解一些 qiang 外资讯</li></ul><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ul><li>VS code 现阶段最佳前端编辑器</li><li>Lepton 代码片段管理</li><li>Dash 离线文档</li><li>iTerm 终端工具</li><li>SwitchHosts 一键切换 hosts</li><li>Axure RP 看原型</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>shadoworcket 够用</li><li>MoneyWiz 管钱的</li></ul>]]></content>
    
    <summary type="html">
    
      我常使用的工具
    
    </summary>
    
    
      <category term="工具" scheme="https://grootfish.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>lodash 的 debounce 实现</title>
    <link href="https://grootfish.github.io/2018/11/07/debounce-in-lodash/"/>
    <id>https://grootfish.github.io/2018/11/07/debounce-in-lodash/</id>
    <published>2018-11-07T08:46:30.000Z</published>
    <updated>2020-12-29T03:10:57.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h1><blockquote><p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!</p></blockquote><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(fn, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这只是简单的实现函数防抖，存在很多问题和局限性。这次来分析一下 lodash 中的 debounce 实现。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><hr><p>在看 lodash 源码之前先来分析一下简单实现存在的问题</p><h3 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h3><hr><p>上面的代码 debounce 返回的函数 this 指向了 Window 对象。在实际需求中我们希望 this 指向正确的对象（一般为触发事件的 DOM 元素）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="event-对象"><a href="#event-对象" class="headerlink" title="event 对象"></a>event 对象</h3><hr><p>我们使用 debounce 方法包装之后，我们会丢失原来事件绑定的 event 对象，我们需要把他找回来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="立即执行问题"><a href="#立即执行问题" class="headerlink" title="立即执行问题"></a>立即执行问题</h3><hr><p>上面的版本解决了 this 指向和 event 对象的问题，但是在实际使用中我们会有一个很常见的需求，我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。我们再来改造原来的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, leading</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (leading) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lodash-的-debounce-实现"><a href="#lodash-的-debounce-实现" class="headerlink" title="lodash 的 debounce 实现"></a>lodash 的 debounce 实现</h2><p>上面的代码已经比较完善了，下面来看下 lodash 中的代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs, lastThis, maxWait, result, timerId, lastCallTime;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数初始化</span></span><br><span class="line">  <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span>; <span class="comment">// func 上一次执行的时间</span></span><br><span class="line">  <span class="keyword">let</span> leading = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> maxing = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> trailing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基本的类型判断和处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func != <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Expected a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait = +wait || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">    <span class="comment">// 对配置的一些初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = lastArgs;</span><br><span class="line">    <span class="keyword">const</span> thisArg = lastThis;</span><br><span class="line"></span><br><span class="line">    lastArgs = lastThis = <span class="literal">undefined</span>;</span><br><span class="line">    lastInvokeTime = time;</span><br><span class="line">    result = func.apply(thisArg, args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Reset any `maxWait` timer.</span></span><br><span class="line">    lastInvokeTime = time;</span><br><span class="line">    <span class="comment">// 为 trailing edge 触发函数调用设定定时器</span></span><br><span class="line">    timerId = setTimeout(timerExpired, wait);</span><br><span class="line">    <span class="comment">// leading = true 执行函数</span></span><br><span class="line">    <span class="keyword">return</span> leading ? invokeFunc(time) : result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime; <span class="comment">// 距离上次debounced函数被调用的时间</span></span><br><span class="line">    <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime; <span class="comment">// 距离上次函数被执行的时间</span></span><br><span class="line">    <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall; <span class="comment">// 用 wait 减去 timeSinceLastCall 计算出下一次trailing的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两种情况</span></span><br><span class="line">    <span class="comment">// 有maxing:比较出下一次maxing和下一次trailing的最小值，作为下一次函数要执行的时间</span></span><br><span class="line">    <span class="comment">// 无maxing：在下一次trailing时执行 timerExpired</span></span><br><span class="line">    <span class="keyword">return</span> maxing</span><br><span class="line">      ? <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class="line">      : timeWaiting;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据时间判断 func 能否被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 几种满足条件的情况</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      lastCallTime === <span class="literal">undefined</span> || <span class="comment">//首次</span></span><br><span class="line">      timeSinceLastCall &gt;= wait || <span class="comment">// 距离上次被调用已经超过 wait</span></span><br><span class="line">      timeSinceLastCall &lt; <span class="number">0</span> || <span class="comment">//系统时间倒退</span></span><br><span class="line">      (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class="line">    ); <span class="comment">//超过最大等待时间</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="comment">// 在 trailing edge 且时间符合条件时，调用 trailingEdge函数，否则重启定时器</span></span><br><span class="line">    <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">      <span class="keyword">return</span> trailingEdge(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重启定时器，保证下一次时延的末尾触发</span></span><br><span class="line">    timerId = setTimeout(timerExpired, remainingWait(time));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    timerId = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有lastArgs才执行，意味着只有 func 已经被 debounced 过一次以后才会在 trailing edge 执行</span></span><br><span class="line">    <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeFunc(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次 trailingEdge 都会清除 lastArgs 和 lastThis，目的是避免最后一次函数被执行了两次</span></span><br><span class="line">    <span class="comment">// 举个例子：最后一次函数执行的时候，可能恰巧是前一次的 trailing edge，函数被调用，而这个函数又需要在自己时延的 trailing edge 触发，导致触发多次</span></span><br><span class="line">    lastArgs = lastThis = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> isInvoking = shouldInvoke(time); <span class="comment">//是否满足时间条件</span></span><br><span class="line"></span><br><span class="line">    lastArgs = args;</span><br><span class="line">    lastThis = <span class="keyword">this</span>;</span><br><span class="line">    lastCallTime = time; <span class="comment">//函数被调用的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 无timerId的情况有两种：1.首次调用 2.trailingEdge执行过函数</span></span><br><span class="line">        <span class="keyword">return</span> leadingEdge(lastCallTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">        <span class="comment">// Handle invocations in a tight loop.</span></span><br><span class="line">        timerId = setTimeout(timerExpired, wait);</span><br><span class="line">        <span class="keyword">return</span> invokeFunc(lastCallTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负责一种case：trailing 为 true 的情况下，在前一个 wait 的 trailingEdge 已经执行了函数；</span></span><br><span class="line">    <span class="comment">// 而这次函数被调用时 shouldInvoke 不满足条件，因此要设置定时器，在本次的 trailingEdge 保证函数被执行</span></span><br><span class="line">    <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      timerId = setTimeout(timerExpired, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  debounced.cancel = cancel;</span><br><span class="line">  debounced.flush = flush;</span><br><span class="line">  debounced.pending = pending;</span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lodash-中的优化"><a href="#lodash-中的优化" class="headerlink" title="lodash 中的优化"></a>lodash 中的优化</h2><ol><li><code>maxWait</code> 参数保证超过一定时间保证调用一次函数</li><li><code>trailing</code> 参数保证延迟结束后调用一次函数</li><li>加了取消(cancel)、刷新(flush)、暂停(pending) 防抖的方法。</li><li>兼容了被包装函数有返回值的情况</li></ol><p>具体使用可以查看<a href="http://lodash.net/docs/4.16.1.html#_debouncefunc-wait0-options" target="_blank" rel="noopener">官方中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;防抖-debounce&quot;&gt;&lt;a href=&quot;#防抖-debounce&quot; class=&quot;headerlink&quot; title=&quot;防抖 debounce&quot;&gt;&lt;/a&gt;防抖 debounce&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;防抖的原理就是：你尽管触发事件，但是我一定
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
      <category term="lodash" scheme="https://grootfish.github.io/tags/lodash/"/>
    
  </entry>
  
  <entry>
    <title>函数节流和函数防抖</title>
    <link href="https://grootfish.github.io/2018/11/02/debounce/"/>
    <id>https://grootfish.github.io/2018/11/02/debounce/</id>
    <published>2018-11-02T06:55:25.000Z</published>
    <updated>2020-12-29T03:10:57.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-throttle-和-debounce"><a href="#什么是-throttle-和-debounce" class="headerlink" title="什么是 throttle 和 debounce"></a>什么是 throttle 和 debounce</h1><hr><blockquote><p>throttle 和 debounce 的功能主要是控制函数调用的频率。</p></blockquote><ul><li><code>throttle</code> 函数节流,将一个函数的调用频率限制在一定阈值内，例如 1s 内一个函数不能被调用两次。</li><li><code>debounce</code> 函数防抖,当调用函数 n 秒后，才会执行该动作，若在这 n 秒内又调用该函数则将取消前一次并重新计算执行时间，举个简单的例子，我们要根据用户输入做 suggest，每当用户按下键盘的时候都可以取消前一次，并且只关心最后一次输入的时间就行了。</li></ul><h2 id="throttle-和-debounce-的应用场景"><a href="#throttle-和-debounce-的应用场景" class="headerlink" title="throttle 和 debounce 的应用场景"></a>throttle 和 debounce 的应用场景</h2><hr><h3 id="throttle-应用场景"><a href="#throttle-应用场景" class="headerlink" title="throttle 应用场景"></a>throttle 应用场景</h3><ul><li>DOM 元素的拖拽功能实现（mousemove）</li><li>监听滚动事件判断是否到页面底部自动加载更多</li></ul><h3 id="debounce-应用场景"><a href="#debounce-应用场景" class="headerlink" title="debounce 应用场景"></a>debounce 应用场景</h3><ul><li>每次 resize/scroll 触发统计事件</li><li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）</li></ul><h3 id="简单实现防抖-debounce"><a href="#简单实现防抖-debounce" class="headerlink" title="简单实现防抖 debounce"></a>简单实现防抖 debounce</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(fn, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(log, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="throttle-就是设置了-maxwait-的-debounce"><a href="#throttle-就是设置了-maxwait-的-debounce" class="headerlink" title="throttle 就是设置了 maxwait 的 debounce"></a>throttle 就是设置了 maxwait 的 debounce</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, maxwait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="literal">null</span>; <span class="comment">//记录上一次运行时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    previous = previous || now;</span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; maxwait) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      fn();</span><br><span class="line">      previous = now;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = setTimeout(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(log, <span class="number">500</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h3 id="Lodash-中的防抖-debounce"><a href="#Lodash-中的防抖-debounce" class="headerlink" title="Lodash 中的防抖 debounce"></a>Lodash 中的防抖 debounce</h3><hr><p>上面的代码只是最简单的实现，存在问题和局限性。下次有机会分享一下 Lodash 中防抖的实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-throttle-和-debounce&quot;&gt;&lt;a href=&quot;#什么是-throttle-和-debounce&quot; class=&quot;headerlink&quot; title=&quot;什么是 throttle 和 debounce&quot;&gt;&lt;/a&gt;什么是 throttle 和 de
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://grootfish.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端代理转发那些事</title>
    <link href="https://grootfish.github.io/2018/09/12/proxy/"/>
    <id>https://grootfish.github.io/2018/09/12/proxy/</id>
    <published>2018-09-12T08:58:19.000Z</published>
    <updated>2020-12-29T03:10:57.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理转发的前世今生"><a href="#代理转发的前世今生" class="headerlink" title="代理转发的前世今生"></a>代理转发的前世今生</h2><hr><blockquote><p>代理对于中国人来说真的是太熟悉不过了，如果你想到外面看看，你就得需要所谓的 vpn。大多数体验过 vpn 上网的就知道代理起到什么样的作用。</p></blockquote><h2 id="为什么使用代理"><a href="#为什么使用代理" class="headerlink" title="为什么使用代理"></a>为什么使用代理</h2><ul><li>分担服务器压力</li><li>缓存资源</li><li>安全</li><li>负载均衡</li><li>压缩资源文件(Gzip)</li><li>……</li></ul><h2 id="前端开发中使用代理"><a href="#前端开发中使用代理" class="headerlink" title="前端开发中使用代理"></a>前端开发中使用代理</h2><hr><ul><li>前后端联调</li><li>解决前端跨域问题</li><li>……</li></ul><h2 id="常用的-web-服务都能实现代理转发"><a href="#常用的-web-服务都能实现代理转发" class="headerlink" title="常用的 web 服务都能实现代理转发"></a>常用的 web 服务都能实现代理转发</h2><hr><ul><li>Tomcat</li><li>Apache</li><li>nginx</li><li>node</li></ul><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><hr><blockquote><p>正向代理代理的是客户端，而反向代理代理的是服务器端。<br>正向代理让服务端不知道谁在请求服务，而反向代理让客户端不知道服务来自哪里。</p></blockquote><h2 id="nginx-常见配置"><a href="#nginx-常见配置" class="headerlink" title="nginx 常见配置"></a>nginx 常见配置</h2><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    # 配置可访问域名，注意需要添加相应host配置</span><br><span class="line">    server_name xxx.dev;</span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = <span class="regexp">/50x.html &#123;</span></span><br><span class="line"><span class="regexp">        root   html;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    location /</span>api/v1 &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        # API Server</span><br><span class="line">        proxy_pass http:<span class="comment">//localhost:4000;</span></span><br><span class="line">        proxy_next_upstream error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="node-实现代理转发"><a href="#node-实现代理转发" class="headerlink" title="node 实现代理转发"></a>node 实现代理转发</h2><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">"http-proxy"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  target: <span class="string">"http://jsonplaceholder.typicode.com/users"</span>,</span><br><span class="line">  changeOrigin: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> httpProxyServer = httpProxy.createProxyServer(options);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonHttpProxy</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  httpProxyServer.web(req, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">"/users"</span>, jsonHttpProxy);</span><br><span class="line">app.listen(<span class="number">3002</span>);</span><br></pre></td></tr></table></figure><h2 id="http-proxy-middleware-简单用法"><a href="#http-proxy-middleware-简单用法" class="headerlink" title="http-proxy-middleware 简单用法"></a>http-proxy-middleware 简单用法</h2><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">"http-proxy-middleware"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">"/api"</span>,</span><br><span class="line">  proxy(&#123;</span><br><span class="line">    target: <span class="string">"http://www.example.org"</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="工作中配合脚手架使用"><a href="#工作中配合脚手架使用" class="headerlink" title="工作中配合脚手架使用"></a>工作中配合脚手架使用</h2><hr><ol><li>在配置文件中<code>proxyTable</code> 代理映射</li><li>使用 <code>http-proxy-middleware</code> 应用代理服务器</li></ol>]]></content>
    
    <summary type="html">
    
      proxy
    
    </summary>
    
    
      <category term="node" scheme="https://grootfish.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>learnyounode-Lesson 7</title>
    <link href="https://grootfish.github.io/2018/03/22/learnyounode-Lesson-7/"/>
    <id>https://grootfish.github.io/2018/03/22/learnyounode-Lesson-7/</id>
    <published>2018-03-22T09:01:16.000Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="课程目标："><a href="#课程目标：" class="headerlink" title="课程目标："></a>课程目标：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Write a program that performs an HTTP GET request to a URL provided to you</span><br><span class="line">  as the first command-line argument. Write the String contents of each</span><br><span class="line">  &quot;data&quot; event from the response to a new line on the console (stdout).</span><br></pre></td></tr></table></figure><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution:"></a>My Solution:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> url = process.argv[<span class="number">2</span>];</span><br><span class="line">http.get(url, (request, response) =&gt; &#123;</span><br><span class="line">  response.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Official-Solution"><a href="#Official-Solution" class="headerlink" title="Official Solution:"></a>Official Solution:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> url = process.argv[<span class="number">2</span>];</span><br><span class="line">http</span><br><span class="line">  .get(url, (request, response) =&gt; &#123;</span><br><span class="line">    response.setEncoding(<span class="string">"utf8"</span>);</span><br><span class="line">    response.on(<span class="string">"data"</span>, <span class="built_in">console</span>.log);</span><br><span class="line">    response.on(<span class="string">"error"</span>, <span class="built_in">console</span>.error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">"error"</span>, <span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><h3 id="课程总结："><a href="#课程总结：" class="headerlink" title="课程总结："></a>课程总结：</h3><p>本节课主要讲的是 node 中 http 模块的使用</p><ol><li><code>http.get()</code>方法的使用。</li><li><code>http.get()</code>回调函数的两个参数是<code>request</code>,<code>response</code>.都是 Node Stream object 类型。</li><li>Node Stream 可以用<code>on</code>方法触发 Node 事件(eg.<code>data</code>、<code>end</code>、<code>error</code>…)</li><li><code>response</code>和<code>requeset</code>默认是 Node buffer 类型。可以直接调用<code>setEncoding</code>方法指定类型，也可以使用<code>toString()</code>等方法转换类型。</li><li>官方解决方法中处理返回错误是最佳实践。</li><li>除了<code>http</code>模块<code>https</code>模块也需要了解。</li></ol>]]></content>
    
    <summary type="html">
    
      learnyounode 学习笔记——Lesson 7 – HTTP Client
    
    </summary>
    
    
      <category term="node" scheme="https://grootfish.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Learnyounode Lesson 6</title>
    <link href="https://grootfish.github.io/2018/03/21/learnyounode-Lesson-6/"/>
    <id>https://grootfish.github.io/2018/03/21/learnyounode-Lesson-6/</id>
    <published>2018-03-21T10:15:56.000Z</published>
    <updated>2020-12-29T03:10:57.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="课程目标："><a href="#课程目标：" class="headerlink" title="课程目标："></a>课程目标：</h3><p>和上一节课一样打印指定文件夹下面的指定后缀的文件列表，但是这节课要封装一个 module 去处理这个问题。module 是 node 的核心概念。一个 node 程序都是由多个 module 组成的。</p><h3 id="My-Solution："><a href="#My-Solution：" class="headerlink" title="My Solution："></a>My Solution：</h3><h4 id="getFiles-module"><a href="#getFiles-module" class="headerlink" title="getFiles module:"></a>getFiles module:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getFiles = <span class="function">(<span class="params">dir, ext, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readdir(dir, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    <span class="keyword">const</span> list = data.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> path.extname(item) === <span class="string">"."</span> + ext;</span><br><span class="line">    &#125;);</span><br><span class="line">    callback(<span class="literal">null</span>, list);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getFiles;</span><br></pre></td></tr></table></figure><h4 id="program-js"><a href="#program-js" class="headerlink" title="program.js:"></a>program.js:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFiles = <span class="built_in">require</span>(<span class="string">"./getFiles"</span>);</span><br><span class="line"><span class="keyword">const</span> dir = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> extname = process.argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">getFiles(dir, extname, (err, list) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.err(err);</span><br><span class="line">  list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="课程总结："><a href="#课程总结：" class="headerlink" title="课程总结："></a>课程总结：</h3><ol><li>封装<code>module</code>是<code>nodejs</code>最基本的能力。要不断巩固提升</li><li><code>module.exports</code>和<code>exports</code>的区别要掌握</li></ol>]]></content>
    
    <summary type="html">
    
      learnyounode 学习笔记——Lesson 6 – Make it Modular
    
    </summary>
    
    
      <category term="node" scheme="https://grootfish.github.io/tags/node/"/>
    
  </entry>
  
</feed>
